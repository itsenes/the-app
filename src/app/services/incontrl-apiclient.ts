/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.11.0.0 (NJsonSchema v9.9.0.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { Http, Headers, ResponseContentType, Response } from '@angular/http';
import { environment } from '../../environments/environment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class ApiClient {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : environment.api_url;
    }

    /**
     * @return Success
     */
    getSubscriptions(filter_Code?: string | null, page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfSubscriptionInfo> {
        let url_ = this.baseUrl + "/subscriptions?";
        if (filter_Code !== undefined)
            url_ += "Filter.Code=" + encodeURIComponent("" + filter_Code) + "&"; 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetSubscriptions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetSubscriptions(response_);
                } catch (e) {
                    return <Observable<ResultSetOfSubscriptionInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfSubscriptionInfo>><any>Observable.throw(response_);
        });
    }

    protected processGetSubscriptions(response: Response): Observable<ResultSetOfSubscriptionInfo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfSubscriptionInfo.fromJS(resultData200) : new ResultSetOfSubscriptionInfo();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfSubscriptionInfo>(<any>null);
    }

    /**
     * @return Success
     */
    createSubscription(request?: CreateSubscriptionRequest | null): Observable<Subscription> {
        let url_ = this.baseUrl + "/subscriptions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateSubscription(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateSubscription(response_);
                } catch (e) {
                    return <Observable<Subscription>><any>Observable.throw(e);
                }
            } else
                return <Observable<Subscription>><any>Observable.throw(response_);
        });
    }

    protected processCreateSubscription(response: Response): Observable<Subscription> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Subscription.fromJS(resultData201) : new Subscription();
            return Observable.of(result201);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Subscription>(<any>null);
    }

    /**
     * Get a single subscription by id
     * @subscriptionId The subscription id to search for
     * @return Success
     */
    getSubscription(subscriptionId: string): Observable<Subscription> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetSubscription(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetSubscription(response_);
                } catch (e) {
                    return <Observable<Subscription>><any>Observable.throw(e);
                }
            } else
                return <Observable<Subscription>><any>Observable.throw(response_);
        });
    }

    protected processGetSubscription(response: Response): Observable<Subscription> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Subscription.fromJS(resultData200) : new Subscription();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Subscription>(<any>null);
    }

    /**
     * @return Success
     */
    getBankAccounts(subscriptionId: string, page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfBankAccountInfo> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/bank-accounts?";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetBankAccounts(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetBankAccounts(response_);
                } catch (e) {
                    return <Observable<ResultSetOfBankAccountInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfBankAccountInfo>><any>Observable.throw(response_);
        });
    }

    protected processGetBankAccounts(response: Response): Observable<ResultSetOfBankAccountInfo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfBankAccountInfo.fromJS(resultData200) : new ResultSetOfBankAccountInfo();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfBankAccountInfo>(<any>null);
    }

    /**
     * @return Success
     */
    createBankAccount(subscriptionId: string, request?: BankAccount | null): Observable<BankAccount> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/bank-accounts";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateBankAccount(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateBankAccount(response_);
                } catch (e) {
                    return <Observable<BankAccount>><any>Observable.throw(e);
                }
            } else
                return <Observable<BankAccount>><any>Observable.throw(response_);
        });
    }

    protected processCreateBankAccount(response: Response): Observable<BankAccount> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? BankAccount.fromJS(resultData201) : new BankAccount();
            return Observable.of(result201);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<BankAccount>(<any>null);
    }

    /**
     * @return Success
     */
    getBankAccount(subscriptionId: string, bankAccountId: string): Observable<BankAccount> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/bank-accounts/{bankAccountId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (bankAccountId === undefined || bankAccountId === null)
            throw new Error("The parameter 'bankAccountId' must be defined.");
        url_ = url_.replace("{bankAccountId}", encodeURIComponent("" + bankAccountId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetBankAccount(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetBankAccount(response_);
                } catch (e) {
                    return <Observable<BankAccount>><any>Observable.throw(e);
                }
            } else
                return <Observable<BankAccount>><any>Observable.throw(response_);
        });
    }

    protected processGetBankAccount(response: Response): Observable<BankAccount> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BankAccount.fromJS(resultData200) : new BankAccount();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<BankAccount>(<any>null);
    }

    /**
     * @return Success
     */
    updateBankAccount(subscriptionId: string, bankAccountId: string, request?: BankAccount | null): Observable<BankAccount> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/bank-accounts/{bankAccountId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (bankAccountId === undefined || bankAccountId === null)
            throw new Error("The parameter 'bankAccountId' must be defined.");
        url_ = url_.replace("{bankAccountId}", encodeURIComponent("" + bankAccountId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateBankAccount(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateBankAccount(response_);
                } catch (e) {
                    return <Observable<BankAccount>><any>Observable.throw(e);
                }
            } else
                return <Observable<BankAccount>><any>Observable.throw(response_);
        });
    }

    protected processUpdateBankAccount(response: Response): Observable<BankAccount> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BankAccount.fromJS(resultData200) : new BankAccount();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<BankAccount>(<any>null);
    }

    /**
     * @return Success
     */
    getBankTransactions(subscriptionId: string, bankAccountId: string, filter_BatchId?: string | null, filter_From?: Date | null, filter_To?: Date | null, page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfBankTransactionInfo> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/bank-accounts/{bankAccountId}/transactions?";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (bankAccountId === undefined || bankAccountId === null)
            throw new Error("The parameter 'bankAccountId' must be defined.");
        url_ = url_.replace("{bankAccountId}", encodeURIComponent("" + bankAccountId)); 
        if (filter_BatchId !== undefined)
            url_ += "Filter.BatchId=" + encodeURIComponent("" + filter_BatchId) + "&"; 
        if (filter_From !== undefined)
            url_ += "Filter.From=" + encodeURIComponent(filter_From ? "" + filter_From.toJSON() : "null") + "&"; 
        if (filter_To !== undefined)
            url_ += "Filter.To=" + encodeURIComponent(filter_To ? "" + filter_To.toJSON() : "null") + "&"; 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetBankTransactions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetBankTransactions(response_);
                } catch (e) {
                    return <Observable<ResultSetOfBankTransactionInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfBankTransactionInfo>><any>Observable.throw(response_);
        });
    }

    protected processGetBankTransactions(response: Response): Observable<ResultSetOfBankTransactionInfo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfBankTransactionInfo.fromJS(resultData200) : new ResultSetOfBankTransactionInfo();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfBankTransactionInfo>(<any>null);
    }

    /**
     * @return Success
     */
    createBankTransaction(subscriptionId: string, bankAccountId: string, request?: BankTransaction | null): Observable<BankTransaction> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/bank-accounts/{bankAccountId}/transactions";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (bankAccountId === undefined || bankAccountId === null)
            throw new Error("The parameter 'bankAccountId' must be defined.");
        url_ = url_.replace("{bankAccountId}", encodeURIComponent("" + bankAccountId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateBankTransaction(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateBankTransaction(response_);
                } catch (e) {
                    return <Observable<BankTransaction>><any>Observable.throw(e);
                }
            } else
                return <Observable<BankTransaction>><any>Observable.throw(response_);
        });
    }

    protected processCreateBankTransaction(response: Response): Observable<BankTransaction> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? BankTransaction.fromJS(resultData201) : new BankTransaction();
            return Observable.of(result201);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<BankTransaction>(<any>null);
    }

    /**
     * @return Success
     */
    getBankTransactionPaymnets(subscriptionId: string, bankAccountId: string, bankTransactionId: string, page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfPaymentInfo> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/bank-accounts/{bankAccountId}/transactions/{bankTransactionId}/payments?";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (bankAccountId === undefined || bankAccountId === null)
            throw new Error("The parameter 'bankAccountId' must be defined.");
        url_ = url_.replace("{bankAccountId}", encodeURIComponent("" + bankAccountId)); 
        if (bankTransactionId === undefined || bankTransactionId === null)
            throw new Error("The parameter 'bankTransactionId' must be defined.");
        url_ = url_.replace("{bankTransactionId}", encodeURIComponent("" + bankTransactionId)); 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetBankTransactionPaymnets(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetBankTransactionPaymnets(response_);
                } catch (e) {
                    return <Observable<ResultSetOfPaymentInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfPaymentInfo>><any>Observable.throw(response_);
        });
    }

    protected processGetBankTransactionPaymnets(response: Response): Observable<ResultSetOfPaymentInfo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfPaymentInfo.fromJS(resultData200) : new ResultSetOfPaymentInfo();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfPaymentInfo>(<any>null);
    }

    /**
     * @return Success
     */
    createBankTransactionPaymnet(subscriptionId: string, bankAccountId: string, bankTransactionId: string, request?: Payment | null): Observable<Payment> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/bank-accounts/{bankAccountId}/transactions/{bankTransactionId}/payments";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (bankAccountId === undefined || bankAccountId === null)
            throw new Error("The parameter 'bankAccountId' must be defined.");
        url_ = url_.replace("{bankAccountId}", encodeURIComponent("" + bankAccountId)); 
        if (bankTransactionId === undefined || bankTransactionId === null)
            throw new Error("The parameter 'bankTransactionId' must be defined.");
        url_ = url_.replace("{bankTransactionId}", encodeURIComponent("" + bankTransactionId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateBankTransactionPaymnet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateBankTransactionPaymnet(response_);
                } catch (e) {
                    return <Observable<Payment>><any>Observable.throw(e);
                }
            } else
                return <Observable<Payment>><any>Observable.throw(response_);
        });
    }

    protected processCreateBankTransactionPaymnet(response: Response): Observable<Payment> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Payment.fromJS(resultData200) : new Payment();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Payment>(<any>null);
    }

    /**
     * @return Success
     */
    getBankTransaction(subscriptionId: string, bankAccountId: string, transactionId: string): Observable<BankTransaction> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/bank-accounts/{bankAccountId}/transactions/{transactionId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (bankAccountId === undefined || bankAccountId === null)
            throw new Error("The parameter 'bankAccountId' must be defined.");
        url_ = url_.replace("{bankAccountId}", encodeURIComponent("" + bankAccountId)); 
        if (transactionId === undefined || transactionId === null)
            throw new Error("The parameter 'transactionId' must be defined.");
        url_ = url_.replace("{transactionId}", encodeURIComponent("" + transactionId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetBankTransaction(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetBankTransaction(response_);
                } catch (e) {
                    return <Observable<BankTransaction>><any>Observable.throw(e);
                }
            } else
                return <Observable<BankTransaction>><any>Observable.throw(response_);
        });
    }

    protected processGetBankTransaction(response: Response): Observable<BankTransaction> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BankTransaction.fromJS(resultData200) : new BankTransaction();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<BankTransaction>(<any>null);
    }

    /**
     * @return Success
     */
    bulkCreateBankTransactions(subscriptionId: string, bankAccountId: string, request?: BulkLoadTransactionsRequest | null): Observable<void> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/bank-accounts/{bankAccountId}/transactions/bulk";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (bankAccountId === undefined || bankAccountId === null)
            throw new Error("The parameter 'bankAccountId' must be defined.");
        url_ = url_.replace("{bankAccountId}", encodeURIComponent("" + bankAccountId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processBulkCreateBankTransactions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processBulkCreateBankTransactions(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processBulkCreateBankTransactions(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getSubscriptionCompany(subscriptionId: string): Observable<Organisation> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/company";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetSubscriptionCompany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetSubscriptionCompany(response_);
                } catch (e) {
                    return <Observable<Organisation>><any>Observable.throw(e);
                }
            } else
                return <Observable<Organisation>><any>Observable.throw(response_);
        });
    }

    protected processGetSubscriptionCompany(response: Response): Observable<Organisation> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Organisation.fromJS(resultData200) : new Organisation();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Organisation>(<any>null);
    }

    /**
     * @return Success
     */
    updateSubscriptionCompany(subscriptionId: string, request?: UpdateSubscriptionCompanyRequest | null): Observable<Organisation> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/company";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateSubscriptionCompany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateSubscriptionCompany(response_);
                } catch (e) {
                    return <Observable<Organisation>><any>Observable.throw(e);
                }
            } else
                return <Observable<Organisation>><any>Observable.throw(response_);
        });
    }

    protected processUpdateSubscriptionCompany(response: Response): Observable<Organisation> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Organisation.fromJS(resultData200) : new Organisation();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Organisation>(<any>null);
    }

    /**
     * @return Success
     */
    getSubscriptionContact(subscriptionId: string): Observable<Contact> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/contact";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetSubscriptionContact(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetSubscriptionContact(response_);
                } catch (e) {
                    return <Observable<Contact>><any>Observable.throw(e);
                }
            } else
                return <Observable<Contact>><any>Observable.throw(response_);
        });
    }

    protected processGetSubscriptionContact(response: Response): Observable<Contact> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Contact.fromJS(resultData200) : new Contact();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Contact>(<any>null);
    }

    /**
     * @return Success
     */
    updateSubscriptionContact(subscriptionId: string, request?: UpdateContactRequest | null): Observable<Contact> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/contact";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateSubscriptionContact(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateSubscriptionContact(response_);
                } catch (e) {
                    return <Observable<Contact>><any>Observable.throw(e);
                }
            } else
                return <Observable<Contact>><any>Observable.throw(response_);
        });
    }

    protected processUpdateSubscriptionContact(response: Response): Observable<Contact> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Contact.fromJS(resultData200) : new Contact();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Contact>(<any>null);
    }

    /**
     * @return Success
     */
    getContacts(subscriptionId: string, filter_Code?: string | null, page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfContactInfo> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/contacts?";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (filter_Code !== undefined)
            url_ += "Filter.Code=" + encodeURIComponent("" + filter_Code) + "&"; 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetContacts(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetContacts(response_);
                } catch (e) {
                    return <Observable<ResultSetOfContactInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfContactInfo>><any>Observable.throw(response_);
        });
    }

    protected processGetContacts(response: Response): Observable<ResultSetOfContactInfo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfContactInfo.fromJS(resultData200) : new ResultSetOfContactInfo();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfContactInfo>(<any>null);
    }

    /**
     * @return Success
     */
    createContact(subscriptionId: string, request?: Contact | null): Observable<Contact> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/contacts";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateContact(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateContact(response_);
                } catch (e) {
                    return <Observable<Contact>><any>Observable.throw(e);
                }
            } else
                return <Observable<Contact>><any>Observable.throw(response_);
        });
    }

    protected processCreateContact(response: Response): Observable<Contact> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Contact.fromJS(resultData201) : new Contact();
            return Observable.of(result201);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Contact>(<any>null);
    }

    /**
     * @return Success
     */
    getContact(subscriptionId: string, contactId: string): Observable<Contact> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/contacts/{contactId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined.");
        url_ = url_.replace("{contactId}", encodeURIComponent("" + contactId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetContact(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetContact(response_);
                } catch (e) {
                    return <Observable<Contact>><any>Observable.throw(e);
                }
            } else
                return <Observable<Contact>><any>Observable.throw(response_);
        });
    }

    protected processGetContact(response: Response): Observable<Contact> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Contact.fromJS(resultData200) : new Contact();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Contact>(<any>null);
    }

    /**
     * @return Success
     */
    updateContact(subscriptionId: string, contactId: string, request?: Contact | null): Observable<Contact> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/contacts/{contactId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined.");
        url_ = url_.replace("{contactId}", encodeURIComponent("" + contactId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateContact(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateContact(response_);
                } catch (e) {
                    return <Observable<Contact>><any>Observable.throw(e);
                }
            } else
                return <Observable<Contact>><any>Observable.throw(response_);
        });
    }

    protected processUpdateContact(response: Response): Observable<Contact> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Contact.fromJS(resultData200) : new Contact();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Contact>(<any>null);
    }

    /**
     * @return Success
     */
    getCompaniesByContact(subscriptionId: string, contactId: string, filter_Customers?: boolean | null, filter_Suppliers?: boolean | null, filter_Code?: string | null, page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfOrganisationInfo> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/contacts/{contactId}/companies?";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined.");
        url_ = url_.replace("{contactId}", encodeURIComponent("" + contactId)); 
        if (filter_Customers !== undefined)
            url_ += "Filter.Customers=" + encodeURIComponent("" + filter_Customers) + "&"; 
        if (filter_Suppliers !== undefined)
            url_ += "Filter.Suppliers=" + encodeURIComponent("" + filter_Suppliers) + "&"; 
        if (filter_Code !== undefined)
            url_ += "Filter.Code=" + encodeURIComponent("" + filter_Code) + "&"; 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetCompaniesByContact(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetCompaniesByContact(response_);
                } catch (e) {
                    return <Observable<ResultSetOfOrganisationInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfOrganisationInfo>><any>Observable.throw(response_);
        });
    }

    protected processGetCompaniesByContact(response: Response): Observable<ResultSetOfOrganisationInfo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfOrganisationInfo.fromJS(resultData200) : new ResultSetOfOrganisationInfo();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfOrganisationInfo>(<any>null);
    }

    /**
     * @return Success
     */
    getInvoices(subscriptionId: string, filter_Number?: string | null, filter_From?: Date | null, filter_To?: Date | null, filter_Status?: Status | null, filter_RecipientCode?: string | null, filter_RecipientId?: string | null, filter_TypeId?: string | null, filter_PaymentCode?: string | null, page?: number | null, size?: number | null, sort?: string | null, search?: string | null, summary?: boolean | null): Observable<ResultSetOfInvoiceInfo> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/invoices?";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (filter_Number !== undefined)
            url_ += "Filter.Number=" + encodeURIComponent("" + filter_Number) + "&"; 
        if (filter_From !== undefined)
            url_ += "Filter.From=" + encodeURIComponent(filter_From ? "" + filter_From.toJSON() : "null") + "&"; 
        if (filter_To !== undefined)
            url_ += "Filter.To=" + encodeURIComponent(filter_To ? "" + filter_To.toJSON() : "null") + "&"; 
        if (filter_Status !== undefined)
            url_ += "Filter.Status=" + encodeURIComponent("" + filter_Status) + "&"; 
        if (filter_RecipientCode !== undefined)
            url_ += "Filter.RecipientCode=" + encodeURIComponent("" + filter_RecipientCode) + "&"; 
        if (filter_RecipientId !== undefined)
            url_ += "Filter.RecipientId=" + encodeURIComponent("" + filter_RecipientId) + "&"; 
        if (filter_TypeId !== undefined)
            url_ += "Filter.TypeId=" + encodeURIComponent("" + filter_TypeId) + "&"; 
        if (filter_PaymentCode !== undefined)
            url_ += "Filter.PaymentCode=" + encodeURIComponent("" + filter_PaymentCode) + "&"; 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        if (summary !== undefined)
            url_ += "summary=" + encodeURIComponent("" + summary) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetInvoices(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetInvoices(response_);
                } catch (e) {
                    return <Observable<ResultSetOfInvoiceInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfInvoiceInfo>><any>Observable.throw(response_);
        });
    }

    protected processGetInvoices(response: Response): Observable<ResultSetOfInvoiceInfo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfInvoiceInfo.fromJS(resultData200) : new ResultSetOfInvoiceInfo();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfInvoiceInfo>(<any>null);
    }

    /**
     * @return Success
     */
    createInvoice(subscriptionId: string, request?: CreateInvoiceRequest | null): Observable<Invoice> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/invoices";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateInvoice(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateInvoice(response_);
                } catch (e) {
                    return <Observable<Invoice>><any>Observable.throw(e);
                }
            } else
                return <Observable<Invoice>><any>Observable.throw(response_);
        });
    }

    protected processCreateInvoice(response: Response): Observable<Invoice> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Invoice.fromJS(resultData201) : new Invoice();
            return Observable.of(result201);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Invoice>(<any>null);
    }

    /**
     * @return Success
     */
    getInvoice(subscriptionId: string, invoiceId: string, format?: string | null): Observable<Invoice> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/invoices/{invoiceId}?";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (invoiceId === undefined || invoiceId === null)
            throw new Error("The parameter 'invoiceId' must be defined.");
        url_ = url_.replace("{invoiceId}", encodeURIComponent("" + invoiceId)); 
        if (format !== undefined)
            url_ += "format=" + encodeURIComponent("" + format) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetInvoice(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetInvoice(response_);
                } catch (e) {
                    return <Observable<Invoice>><any>Observable.throw(e);
                }
            } else
                return <Observable<Invoice>><any>Observable.throw(response_);
        });
    }

    protected processGetInvoice(response: Response): Observable<Invoice> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Invoice.fromJS(resultData200) : new Invoice();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Invoice>(<any>null);
    }

    /**
     * @return Success
     */
    updateInvoice(subscriptionId: string, invoiceId: string, request?: UpdateInvoiceRequest | null): Observable<Invoice> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/invoices/{invoiceId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (invoiceId === undefined || invoiceId === null)
            throw new Error("The parameter 'invoiceId' must be defined.");
        url_ = url_.replace("{invoiceId}", encodeURIComponent("" + invoiceId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateInvoice(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateInvoice(response_);
                } catch (e) {
                    return <Observable<Invoice>><any>Observable.throw(e);
                }
            } else
                return <Observable<Invoice>><any>Observable.throw(response_);
        });
    }

    protected processUpdateInvoice(response: Response): Observable<Invoice> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Invoice.fromJS(resultData200) : new Invoice();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Invoice>(<any>null);
    }

    /**
     * @return Success
     */
    deleteInvoice(subscriptionId: string, invoiceId: string): Observable<void> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/invoices/{invoiceId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (invoiceId === undefined || invoiceId === null)
            throw new Error("The parameter 'invoiceId' must be defined.");
        url_ = url_.replace("{invoiceId}", encodeURIComponent("" + invoiceId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeleteInvoice(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteInvoice(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteInvoice(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getInvoiceStatus(subscriptionId: string, invoiceId: string): Observable<InvoiceStatusResponse> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/invoices/{invoiceId}/status";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (invoiceId === undefined || invoiceId === null)
            throw new Error("The parameter 'invoiceId' must be defined.");
        url_ = url_.replace("{invoiceId}", encodeURIComponent("" + invoiceId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetInvoiceStatus(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetInvoiceStatus(response_);
                } catch (e) {
                    return <Observable<InvoiceStatusResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<InvoiceStatusResponse>><any>Observable.throw(response_);
        });
    }

    protected processGetInvoiceStatus(response: Response): Observable<InvoiceStatusResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InvoiceStatusResponse.fromJS(resultData200) : new InvoiceStatusResponse();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<InvoiceStatusResponse>(<any>null);
    }

    /**
     * @return Success
     */
    changeInvoiceStatus(subscriptionId: string, invoiceId: string, request?: ChangeInvoiceStatusRequest | null): Observable<InvoiceStatusResponse> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/invoices/{invoiceId}/status";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (invoiceId === undefined || invoiceId === null)
            throw new Error("The parameter 'invoiceId' must be defined.");
        url_ = url_.replace("{invoiceId}", encodeURIComponent("" + invoiceId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processChangeInvoiceStatus(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processChangeInvoiceStatus(response_);
                } catch (e) {
                    return <Observable<InvoiceStatusResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<InvoiceStatusResponse>><any>Observable.throw(response_);
        });
    }

    protected processChangeInvoiceStatus(response: Response): Observable<InvoiceStatusResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InvoiceStatusResponse.fromJS(resultData200) : new InvoiceStatusResponse();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<InvoiceStatusResponse>(<any>null);
    }

    /**
     * @return Success
     */
    getViews(subscriptionId: string, invoiceId: string, page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfTrackingInfo> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/invoices/{invoiceId}/trackings?";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (invoiceId === undefined || invoiceId === null)
            throw new Error("The parameter 'invoiceId' must be defined.");
        url_ = url_.replace("{invoiceId}", encodeURIComponent("" + invoiceId)); 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetViews(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetViews(response_);
                } catch (e) {
                    return <Observable<ResultSetOfTrackingInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfTrackingInfo>><any>Observable.throw(response_);
        });
    }

    protected processGetViews(response: Response): Observable<ResultSetOfTrackingInfo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfTrackingInfo.fromJS(resultData200) : new ResultSetOfTrackingInfo();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfTrackingInfo>(<any>null);
    }

    /**
     * @return Success
     */
    generateTracker(subscriptionId: string, invoiceId: string, request?: InvoiceTrackingRequest | null): Observable<Tracker> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/invoices/{invoiceId}/trackings";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (invoiceId === undefined || invoiceId === null)
            throw new Error("The parameter 'invoiceId' must be defined.");
        url_ = url_.replace("{invoiceId}", encodeURIComponent("" + invoiceId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGenerateTracker(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGenerateTracker(response_);
                } catch (e) {
                    return <Observable<Tracker>><any>Observable.throw(e);
                }
            } else
                return <Observable<Tracker>><any>Observable.throw(response_);
        });
    }

    protected processGenerateTracker(response: Response): Observable<Tracker> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Tracker.fromJS(resultData200) : new Tracker();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Tracker>(<any>null);
    }

    /**
     * @return Success
     */
    getInvoiceType(subscriptionId: string, invoiceId: string): Observable<InvoiceType> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/invoices/{invoiceId}/type";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (invoiceId === undefined || invoiceId === null)
            throw new Error("The parameter 'invoiceId' must be defined.");
        url_ = url_.replace("{invoiceId}", encodeURIComponent("" + invoiceId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetInvoiceType(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetInvoiceType(response_);
                } catch (e) {
                    return <Observable<InvoiceType>><any>Observable.throw(e);
                }
            } else
                return <Observable<InvoiceType>><any>Observable.throw(response_);
        });
    }

    protected processGetInvoiceType(response: Response): Observable<InvoiceType> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InvoiceType.fromJS(resultData200) : new InvoiceType();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<InvoiceType>(<any>null);
    }

    /**
     * @return Success
     */
    changeInvoiceType(subscriptionId: string, invoiceId: string, request?: ChangeInvoiceTypeRequest | null): Observable<InvoiceType> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/invoices/{invoiceId}/type";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (invoiceId === undefined || invoiceId === null)
            throw new Error("The parameter 'invoiceId' must be defined.");
        url_ = url_.replace("{invoiceId}", encodeURIComponent("" + invoiceId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processChangeInvoiceType(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processChangeInvoiceType(response_);
                } catch (e) {
                    return <Observable<InvoiceType>><any>Observable.throw(e);
                }
            } else
                return <Observable<InvoiceType>><any>Observable.throw(response_);
        });
    }

    protected processChangeInvoiceType(response: Response): Observable<InvoiceType> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InvoiceType.fromJS(resultData200) : new InvoiceType();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<InvoiceType>(<any>null);
    }

    /**
     * @return Success
     */
    getInvoiceTypes(subscriptionId: string, page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfInvoiceType> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/invoice-types?";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetInvoiceTypes(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetInvoiceTypes(response_);
                } catch (e) {
                    return <Observable<ResultSetOfInvoiceType>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfInvoiceType>><any>Observable.throw(response_);
        });
    }

    protected processGetInvoiceTypes(response: Response): Observable<ResultSetOfInvoiceType> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfInvoiceType.fromJS(resultData200) : new ResultSetOfInvoiceType();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfInvoiceType>(<any>null);
    }

    /**
     * @return Success
     */
    createInvoiceType(subscriptionId: string, request?: CreateInvoiceTypeRequest | null): Observable<InvoiceType> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/invoice-types";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateInvoiceType(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateInvoiceType(response_);
                } catch (e) {
                    return <Observable<InvoiceType>><any>Observable.throw(e);
                }
            } else
                return <Observable<InvoiceType>><any>Observable.throw(response_);
        });
    }

    protected processCreateInvoiceType(response: Response): Observable<InvoiceType> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? InvoiceType.fromJS(resultData201) : new InvoiceType();
            return Observable.of(result201);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<InvoiceType>(<any>null);
    }

    /**
     * @return Success
     */
    getInvoiceType2(subscriptionId: string, invoiceTypeId: string): Observable<InvoiceType> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/invoice-types/{invoiceTypeId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (invoiceTypeId === undefined || invoiceTypeId === null)
            throw new Error("The parameter 'invoiceTypeId' must be defined.");
        url_ = url_.replace("{invoiceTypeId}", encodeURIComponent("" + invoiceTypeId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetInvoiceType2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetInvoiceType2(response_);
                } catch (e) {
                    return <Observable<InvoiceType>><any>Observable.throw(e);
                }
            } else
                return <Observable<InvoiceType>><any>Observable.throw(response_);
        });
    }

    protected processGetInvoiceType2(response: Response): Observable<InvoiceType> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InvoiceType.fromJS(resultData200) : new InvoiceType();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<InvoiceType>(<any>null);
    }

    /**
     * @return Success
     */
    updateInvoiceType(subscriptionId: string, invoiceTypeId: string, request?: UpdateInvoiceTypeRequest | null): Observable<InvoiceType> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/invoice-types/{invoiceTypeId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (invoiceTypeId === undefined || invoiceTypeId === null)
            throw new Error("The parameter 'invoiceTypeId' must be defined.");
        url_ = url_.replace("{invoiceTypeId}", encodeURIComponent("" + invoiceTypeId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateInvoiceType(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateInvoiceType(response_);
                } catch (e) {
                    return <Observable<InvoiceType>><any>Observable.throw(e);
                }
            } else
                return <Observable<InvoiceType>><any>Observable.throw(response_);
        });
    }

    protected processUpdateInvoiceType(response: Response): Observable<InvoiceType> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InvoiceType.fromJS(resultData200) : new InvoiceType();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<InvoiceType>(<any>null);
    }

    /**
     * @return Success
     */
    deleteInvoiceType(subscriptionId: string, invoiceTypeId: string): Observable<void> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/invoice-types/{invoiceTypeId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (invoiceTypeId === undefined || invoiceTypeId === null)
            throw new Error("The parameter 'invoiceTypeId' must be defined.");
        url_ = url_.replace("{invoiceTypeId}", encodeURIComponent("" + invoiceTypeId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeleteInvoiceType(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteInvoiceType(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteInvoiceType(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getInvoiceTypeTemplate(subscriptionId: string, invoiceTypeId: string): Observable<void> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/invoice-types/{invoiceTypeId}/template";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (invoiceTypeId === undefined || invoiceTypeId === null)
            throw new Error("The parameter 'invoiceTypeId' must be defined.");
        url_ = url_.replace("{invoiceTypeId}", encodeURIComponent("" + invoiceTypeId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetInvoiceTypeTemplate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetInvoiceTypeTemplate(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processGetInvoiceTypeTemplate(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    updateInvoiceTypeTemplate(subscriptionId: string, invoiceTypeId: string, file?: FileParameter | null): Observable<void> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/invoice-types/{invoiceTypeId}/template";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (invoiceTypeId === undefined || invoiceTypeId === null)
            throw new Error("The parameter 'invoiceTypeId' must be defined.");
        url_ = url_.replace("{invoiceTypeId}", encodeURIComponent("" + invoiceTypeId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");
        
        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateInvoiceTypeTemplate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateInvoiceTypeTemplate(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateInvoiceTypeTemplate(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getSubscriptionMetrics(subscriptionId: string, filter_From?: Date | null, filter_To?: Date | null, page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfMetricsRecord> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/metrics?";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (filter_From !== undefined)
            url_ += "Filter.From=" + encodeURIComponent(filter_From ? "" + filter_From.toJSON() : "null") + "&"; 
        if (filter_To !== undefined)
            url_ += "Filter.To=" + encodeURIComponent(filter_To ? "" + filter_To.toJSON() : "null") + "&"; 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetSubscriptionMetrics(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetSubscriptionMetrics(response_);
                } catch (e) {
                    return <Observable<ResultSetOfMetricsRecord>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfMetricsRecord>><any>Observable.throw(response_);
        });
    }

    protected processGetSubscriptionMetrics(response: Response): Observable<ResultSetOfMetricsRecord> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfMetricsRecord.fromJS(resultData200) : new ResultSetOfMetricsRecord();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfMetricsRecord>(<any>null);
    }

    /**
     * @return Success
     */
    getOrganisations(subscriptionId: string, filter_Customers?: boolean | null, filter_Suppliers?: boolean | null, filter_Code?: string | null, page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfOrganisationInfo> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/organisations?";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (filter_Customers !== undefined)
            url_ += "Filter.Customers=" + encodeURIComponent("" + filter_Customers) + "&"; 
        if (filter_Suppliers !== undefined)
            url_ += "Filter.Suppliers=" + encodeURIComponent("" + filter_Suppliers) + "&"; 
        if (filter_Code !== undefined)
            url_ += "Filter.Code=" + encodeURIComponent("" + filter_Code) + "&"; 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetOrganisations(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetOrganisations(response_);
                } catch (e) {
                    return <Observable<ResultSetOfOrganisationInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfOrganisationInfo>><any>Observable.throw(response_);
        });
    }

    protected processGetOrganisations(response: Response): Observable<ResultSetOfOrganisationInfo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfOrganisationInfo.fromJS(resultData200) : new ResultSetOfOrganisationInfo();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfOrganisationInfo>(<any>null);
    }

    /**
     * @return Success
     */
    createOrganisation(subscriptionId: string, request?: Organisation | null): Observable<Organisation> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/organisations";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateOrganisation(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateOrganisation(response_);
                } catch (e) {
                    return <Observable<Organisation>><any>Observable.throw(e);
                }
            } else
                return <Observable<Organisation>><any>Observable.throw(response_);
        });
    }

    protected processCreateOrganisation(response: Response): Observable<Organisation> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Organisation.fromJS(resultData201) : new Organisation();
            return Observable.of(result201);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Organisation>(<any>null);
    }

    /**
     * @return Success
     */
    getOrganisation(subscriptionId: string, organisationId: string): Observable<Organisation> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/organisations/{organisationId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (organisationId === undefined || organisationId === null)
            throw new Error("The parameter 'organisationId' must be defined.");
        url_ = url_.replace("{organisationId}", encodeURIComponent("" + organisationId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetOrganisation(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetOrganisation(response_);
                } catch (e) {
                    return <Observable<Organisation>><any>Observable.throw(e);
                }
            } else
                return <Observable<Organisation>><any>Observable.throw(response_);
        });
    }

    protected processGetOrganisation(response: Response): Observable<Organisation> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Organisation.fromJS(resultData200) : new Organisation();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Organisation>(<any>null);
    }

    /**
     * @return Success
     */
    updateOrganisation(subscriptionId: string, organisationId: string, request?: UpdateOrganisationRequest | null): Observable<Organisation> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/organisations/{organisationId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (organisationId === undefined || organisationId === null)
            throw new Error("The parameter 'organisationId' must be defined.");
        url_ = url_.replace("{organisationId}", encodeURIComponent("" + organisationId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateOrganisation(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateOrganisation(response_);
                } catch (e) {
                    return <Observable<Organisation>><any>Observable.throw(e);
                }
            } else
                return <Observable<Organisation>><any>Observable.throw(response_);
        });
    }

    protected processUpdateOrganisation(response: Response): Observable<Organisation> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Organisation.fromJS(resultData200) : new Organisation();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Organisation>(<any>null);
    }

    /**
     * @return Success
     */
    getProducts(subscriptionId: string, page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfProductInfo> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/products?";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetProducts(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetProducts(response_);
                } catch (e) {
                    return <Observable<ResultSetOfProductInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfProductInfo>><any>Observable.throw(response_);
        });
    }

    protected processGetProducts(response: Response): Observable<ResultSetOfProductInfo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfProductInfo.fromJS(resultData200) : new ResultSetOfProductInfo();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfProductInfo>(<any>null);
    }

    /**
     * @return Success
     */
    createProduct(subscriptionId: string, request?: Product | null): Observable<Product> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/products";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateProduct(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateProduct(response_);
                } catch (e) {
                    return <Observable<Product>><any>Observable.throw(e);
                }
            } else
                return <Observable<Product>><any>Observable.throw(response_);
        });
    }

    protected processCreateProduct(response: Response): Observable<Product> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Product.fromJS(resultData201) : new Product();
            return Observable.of(result201);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Product>(<any>null);
    }

    /**
     * @return Success
     */
    getProduct(subscriptionId: string, productId: string): Observable<Product> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/products/{productId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetProduct(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetProduct(response_);
                } catch (e) {
                    return <Observable<Product>><any>Observable.throw(e);
                }
            } else
                return <Observable<Product>><any>Observable.throw(response_);
        });
    }

    protected processGetProduct(response: Response): Observable<Product> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Product.fromJS(resultData200) : new Product();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Product>(<any>null);
    }

    /**
     * @return Success
     */
    updateProduct(subscriptionId: string, productId: string, request?: Product | null): Observable<Product> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/products/{productId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateProduct(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateProduct(response_);
                } catch (e) {
                    return <Observable<Product>><any>Observable.throw(e);
                }
            } else
                return <Observable<Product>><any>Observable.throw(response_);
        });
    }

    protected processUpdateProduct(response: Response): Observable<Product> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Product.fromJS(resultData200) : new Product();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Product>(<any>null);
    }

    /**
     * @return Success
     */
    getSubscriptionStatus(subscriptionId: string): Observable<Subscription> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/status";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetSubscriptionStatus(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetSubscriptionStatus(response_);
                } catch (e) {
                    return <Observable<Subscription>><any>Observable.throw(e);
                }
            } else
                return <Observable<Subscription>><any>Observable.throw(response_);
        });
    }

    protected processGetSubscriptionStatus(response: Response): Observable<Subscription> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Subscription.fromJS(resultData200) : new Subscription();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Subscription>(<any>null);
    }

    /**
     * @return Success
     */
    updateSubscriptionStatus(subscriptionId: string, request?: UpdateSubscriptionStatusRequest | null): Observable<Subscription> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/status";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateSubscriptionStatus(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateSubscriptionStatus(response_);
                } catch (e) {
                    return <Observable<Subscription>><any>Observable.throw(e);
                }
            } else
                return <Observable<Subscription>><any>Observable.throw(response_);
        });
    }

    protected processUpdateSubscriptionStatus(response: Response): Observable<Subscription> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Subscription.fromJS(resultData200) : new Subscription();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Subscription>(<any>null);
    }

    /**
     * @return Success
     */
    updateSubscriptionTimeZone(subscriptionId: string, request?: UpdateSubscriptionTimeZoneRequest | null): Observable<void> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/time-zone";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);
        
        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateSubscriptionTimeZone(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateSubscriptionTimeZone(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateSubscriptionTimeZone(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getGlobalMetrics(filter_From?: Date | null, filter_To?: Date | null, page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfMetricsRecord> {
        let url_ = this.baseUrl + "/subscriptions/all/metrics?";
        if (filter_From !== undefined)
            url_ += "Filter.From=" + encodeURIComponent(filter_From ? "" + filter_From.toJSON() : "null") + "&"; 
        if (filter_To !== undefined)
            url_ += "Filter.To=" + encodeURIComponent(filter_To ? "" + filter_To.toJSON() : "null") + "&"; 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetGlobalMetrics(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetGlobalMetrics(response_);
                } catch (e) {
                    return <Observable<ResultSetOfMetricsRecord>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfMetricsRecord>><any>Observable.throw(response_);
        });
    }

    protected processGetGlobalMetrics(response: Response): Observable<ResultSetOfMetricsRecord> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfMetricsRecord.fromJS(resultData200) : new ResultSetOfMetricsRecord();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfMetricsRecord>(<any>null);
    }
}

export class ResultSetOfSubscriptionInfo {
    count?: number | undefined;
    items?: Subscription[] | undefined;

    init(data?: any) {
        if (data) {
            this.count = data["count"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Subscription.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultSetOfSubscriptionInfo {
        let result = new ResultSetOfSubscriptionInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ResultSetOfSubscriptionInfo();
        result.init(json);
        return result;
    }
}

export class Subscription {
    id?: string | undefined;
    code?: string | undefined;
    alias?: string | undefined;
    timeZone?: string | undefined;
    status?: SubscriptionStatus | undefined;
    company?: Organisation | undefined;
    contact?: Contact | undefined;
    notes?: string | undefined;
    customData?: any | undefined;

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.code = data["code"];
            this.alias = data["alias"];
            this.timeZone = data["timeZone"];
            this.status = data["status"];
            this.company = data["company"] ? Organisation.fromJS(data["company"]) : <any>undefined;
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : <any>undefined;
            this.notes = data["notes"];
            if (data["customData"]) {
                this.customData = {};
                for (let key in data["customData"]) {
                    if (data["customData"].hasOwnProperty(key))
                        this.customData[key] = data["customData"][key];
                }
            }
        }
    }

    static fromJS(data: any): Subscription {
        let result = new Subscription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["alias"] = this.alias;
        data["timeZone"] = this.timeZone;
        data["status"] = this.status;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["notes"] = this.notes;
        if (this.customData) {
            data["customData"] = {};
            for (let key in this.customData) {
                if (this.customData.hasOwnProperty(key))
                    data["customData"][key] = this.customData[key];
            }
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Subscription();
        result.init(json);
        return result;
    }
}

export class Organisation {
    id?: string | undefined;
    code?: string | undefined;
    logoPath?: string | undefined;
    name: string;
    legalName?: string | undefined;
    lineOfBusiness?: string | undefined;
    taxCode?: string | undefined;
    taxOffice?: string | undefined;
    currencyCode?: string | undefined;
    address: Address = new Address();
    email?: string | undefined;
    website?: string | undefined;
    notes?: string | undefined;
    customData?: any | undefined;
    paymentMethods?: PaymentOption[] | undefined;

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.code = data["code"];
            this.logoPath = data["logoPath"];
            this.name = data["name"];
            this.legalName = data["legalName"];
            this.lineOfBusiness = data["lineOfBusiness"];
            this.taxCode = data["taxCode"];
            this.taxOffice = data["taxOffice"];
            this.currencyCode = data["currencyCode"];
            this.address = data["address"] ? Address.fromJS(data["address"]) : new Address();
            this.email = data["email"];
            this.website = data["website"];
            this.notes = data["notes"];
            if (data["customData"]) {
                this.customData = {};
                for (let key in data["customData"]) {
                    if (data["customData"].hasOwnProperty(key))
                        this.customData[key] = data["customData"][key];
                }
            }
            if (data["paymentMethods"] && data["paymentMethods"].constructor === Array) {
                this.paymentMethods = [];
                for (let item of data["paymentMethods"])
                    this.paymentMethods.push(PaymentOption.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Organisation {
        let result = new Organisation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["logoPath"] = this.logoPath;
        data["name"] = this.name;
        data["legalName"] = this.legalName;
        data["lineOfBusiness"] = this.lineOfBusiness;
        data["taxCode"] = this.taxCode;
        data["taxOffice"] = this.taxOffice;
        data["currencyCode"] = this.currencyCode;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["email"] = this.email;
        data["website"] = this.website;
        data["notes"] = this.notes;
        if (this.customData) {
            data["customData"] = {};
            for (let key in this.customData) {
                if (this.customData.hasOwnProperty(key))
                    data["customData"][key] = this.customData[key];
            }
        }
        if (this.paymentMethods && this.paymentMethods.constructor === Array) {
            data["paymentMethods"] = [];
            for (let item of this.paymentMethods)
                data["paymentMethods"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Organisation();
        result.init(json);
        return result;
    }
}

export class Contact {
    id?: string | undefined;
    code?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    address?: Address | undefined;
    phone1?: string | undefined;
    phone2?: string | undefined;
    skype?: string | undefined;
    notes?: string | undefined;
    customData?: any | undefined;

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.code = data["code"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.address = data["address"] ? Address.fromJS(data["address"]) : <any>undefined;
            this.phone1 = data["phone1"];
            this.phone2 = data["phone2"];
            this.skype = data["skype"];
            this.notes = data["notes"];
            if (data["customData"]) {
                this.customData = {};
                for (let key in data["customData"]) {
                    if (data["customData"].hasOwnProperty(key))
                        this.customData[key] = data["customData"][key];
                }
            }
        }
    }

    static fromJS(data: any): Contact {
        let result = new Contact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["phone1"] = this.phone1;
        data["phone2"] = this.phone2;
        data["skype"] = this.skype;
        data["notes"] = this.notes;
        if (this.customData) {
            data["customData"] = {};
            for (let key in this.customData) {
                if (this.customData.hasOwnProperty(key))
                    data["customData"][key] = this.customData[key];
            }
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Contact();
        result.init(json);
        return result;
    }
}

export class Address {
    name?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    city?: string | undefined;
    zipCode?: string | undefined;
    countryCode: string;
    readonly country?: string | undefined;
    phone1?: string | undefined;
    phone2?: string | undefined;
    notes?: string | undefined;

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.line1 = data["line1"];
            this.line2 = data["line2"];
            this.city = data["city"];
            this.zipCode = data["zipCode"];
            this.countryCode = data["countryCode"];
            (<any>this).country = data["country"];
            this.phone1 = data["phone1"];
            this.phone2 = data["phone2"];
            this.notes = data["notes"];
        }
    }

    static fromJS(data: any): Address {
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["city"] = this.city;
        data["zipCode"] = this.zipCode;
        data["countryCode"] = this.countryCode;
        data["country"] = this.country;
        data["phone1"] = this.phone1;
        data["phone2"] = this.phone2;
        data["notes"] = this.notes;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Address();
        result.init(json);
        return result;
    }
}

export class PaymentOption {
    code?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    type?: PaymentOptionType | undefined;

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.description = data["description"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): PaymentOption {
        let result = new PaymentOption();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["type"] = this.type;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PaymentOption();
        result.init(json);
        return result;
    }
}

export class CreateSubscriptionRequest {
    type?: CreateSubscriptionRequestType | undefined;
    code?: string | undefined;
    alias?: string | undefined;
    timeZone?: string | undefined;
    company: Organisation = new Organisation();
    contact: Contact = new Contact();
    notes?: string | undefined;
    customData?: any | undefined;

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.code = data["code"];
            this.alias = data["alias"];
            this.timeZone = data["timeZone"];
            this.company = data["company"] ? Organisation.fromJS(data["company"]) : new Organisation();
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : new Contact();
            this.notes = data["notes"];
            if (data["customData"]) {
                this.customData = {};
                for (let key in data["customData"]) {
                    if (data["customData"].hasOwnProperty(key))
                        this.customData[key] = data["customData"][key];
                }
            }
        }
    }

    static fromJS(data: any): CreateSubscriptionRequest {
        let result = new CreateSubscriptionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["code"] = this.code;
        data["alias"] = this.alias;
        data["timeZone"] = this.timeZone;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["notes"] = this.notes;
        if (this.customData) {
            data["customData"] = {};
            for (let key in this.customData) {
                if (this.customData.hasOwnProperty(key))
                    data["customData"][key] = this.customData[key];
            }
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CreateSubscriptionRequest();
        result.init(json);
        return result;
    }
}

export class ResultSetOfBankAccountInfo {
    count?: number | undefined;
    items?: BankAccount[] | undefined;

    init(data?: any) {
        if (data) {
            this.count = data["count"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(BankAccount.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultSetOfBankAccountInfo {
        let result = new ResultSetOfBankAccountInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ResultSetOfBankAccountInfo();
        result.init(json);
        return result;
    }
}

export class BankAccount {
    id?: string | undefined;
    code?: string | undefined;
    bank: string;
    number: string;
    name?: string | undefined;
    baseline?: Balance | undefined;
    provider?: TransactionProviderConfig | undefined;
    reconciliation?: ReconciliationConfig | undefined;

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.code = data["code"];
            this.bank = data["bank"];
            this.number = data["number"];
            this.name = data["name"];
            this.baseline = data["baseline"] ? Balance.fromJS(data["baseline"]) : <any>undefined;
            this.provider = data["provider"] ? TransactionProviderConfig.fromJS(data["provider"]) : <any>undefined;
            this.reconciliation = data["reconciliation"] ? ReconciliationConfig.fromJS(data["reconciliation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BankAccount {
        let result = new BankAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["bank"] = this.bank;
        data["number"] = this.number;
        data["name"] = this.name;
        data["baseline"] = this.baseline ? this.baseline.toJSON() : <any>undefined;
        data["provider"] = this.provider ? this.provider.toJSON() : <any>undefined;
        data["reconciliation"] = this.reconciliation ? this.reconciliation.toJSON() : <any>undefined;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new BankAccount();
        result.init(json);
        return result;
    }
}

export class Balance {
    amount?: number | undefined;
    date?: Date | undefined;

    init(data?: any) {
        if (data) {
            this.amount = data["amount"];
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Balance {
        let result = new Balance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Balance();
        result.init(json);
        return result;
    }
}

export class TransactionProviderConfig {
    name?: string | undefined;
    settings?: any | undefined;

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["settings"]) {
                this.settings = {};
                for (let key in data["settings"]) {
                    if (data["settings"].hasOwnProperty(key))
                        this.settings[key] = data["settings"][key];
                }
            }
        }
    }

    static fromJS(data: any): TransactionProviderConfig {
        let result = new TransactionProviderConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.settings) {
            data["settings"] = {};
            for (let key in this.settings) {
                if (this.settings.hasOwnProperty(key))
                    data["settings"][key] = this.settings[key];
            }
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new TransactionProviderConfig();
        result.init(json);
        return result;
    }
}

export class ReconciliationConfig {
    backwardsLookup?: string | undefined;
    algorithm?: string | undefined;
    invoiceTypes?: string[] | undefined;

    init(data?: any) {
        if (data) {
            this.backwardsLookup = data["backwardsLookup"];
            this.algorithm = data["algorithm"];
            if (data["invoiceTypes"] && data["invoiceTypes"].constructor === Array) {
                this.invoiceTypes = [];
                for (let item of data["invoiceTypes"])
                    this.invoiceTypes.push(item);
            }
        }
    }

    static fromJS(data: any): ReconciliationConfig {
        let result = new ReconciliationConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["backwardsLookup"] = this.backwardsLookup;
        data["algorithm"] = this.algorithm;
        if (this.invoiceTypes && this.invoiceTypes.constructor === Array) {
            data["invoiceTypes"] = [];
            for (let item of this.invoiceTypes)
                data["invoiceTypes"].push(item);
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ReconciliationConfig();
        result.init(json);
        return result;
    }
}

export class ResultSetOfBankTransactionInfo {
    count?: number | undefined;
    items?: BankTransaction[] | undefined;

    init(data?: any) {
        if (data) {
            this.count = data["count"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(BankTransaction.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultSetOfBankTransactionInfo {
        let result = new ResultSetOfBankTransactionInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ResultSetOfBankTransactionInfo();
        result.init(json);
        return result;
    }
}

export class BankTransaction {
    id?: string | undefined;
    hash?: string | undefined;
    type: BankTransactionType;
    date: Date;
    number?: string | undefined;
    text?: string | undefined;
    amount: number;

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.hash = data["hash"];
            this.type = data["type"];
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>undefined;
            this.number = data["number"];
            this.text = data["text"];
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): BankTransaction {
        let result = new BankTransaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["hash"] = this.hash;
        data["type"] = this.type;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["number"] = this.number;
        data["text"] = this.text;
        data["amount"] = this.amount;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new BankTransaction();
        result.init(json);
        return result;
    }
}

export class Payment {
    id?: string | undefined;
    invoiceId?: string | undefined;
    transactionId?: string | undefined;
    approval?: PaymentApproval | undefined;
    amount?: number | undefined;
    comments?: string | undefined;

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.invoiceId = data["invoiceId"];
            this.transactionId = data["transactionId"];
            this.approval = data["approval"];
            this.amount = data["amount"];
            this.comments = data["comments"];
        }
    }

    static fromJS(data: any): Payment {
        let result = new Payment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["invoiceId"] = this.invoiceId;
        data["transactionId"] = this.transactionId;
        data["approval"] = this.approval;
        data["amount"] = this.amount;
        data["comments"] = this.comments;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Payment();
        result.init(json);
        return result;
    }
}

export class ResultSetOfPaymentInfo {
    count?: number | undefined;
    items?: Payment[] | undefined;

    init(data?: any) {
        if (data) {
            this.count = data["count"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Payment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultSetOfPaymentInfo {
        let result = new ResultSetOfPaymentInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ResultSetOfPaymentInfo();
        result.init(json);
        return result;
    }
}

export class BulkLoadTransactionsRequest {
    batchId?: string | undefined;
    data: BankTransaction[] = [];

    init(data?: any) {
        if (data) {
            this.batchId = data["batchId"];
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(BankTransaction.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BulkLoadTransactionsRequest {
        let result = new BulkLoadTransactionsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["batchId"] = this.batchId;
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new BulkLoadTransactionsRequest();
        result.init(json);
        return result;
    }
}

export class UpdateSubscriptionCompanyRequest {
    code?: string | undefined;
    logoPath?: string | undefined;
    name: string;
    legalName?: string | undefined;
    lineOfBusiness?: string | undefined;
    taxCode?: string | undefined;
    taxOffice?: string | undefined;
    currencyCode?: string | undefined;
    address: Address = new Address();
    email: string;
    website?: string | undefined;
    notes?: string | undefined;
    customData?: any | undefined;
    paymentMethods?: PaymentOption[] | undefined;

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.logoPath = data["logoPath"];
            this.name = data["name"];
            this.legalName = data["legalName"];
            this.lineOfBusiness = data["lineOfBusiness"];
            this.taxCode = data["taxCode"];
            this.taxOffice = data["taxOffice"];
            this.currencyCode = data["currencyCode"];
            this.address = data["address"] ? Address.fromJS(data["address"]) : new Address();
            this.email = data["email"];
            this.website = data["website"];
            this.notes = data["notes"];
            if (data["customData"]) {
                this.customData = {};
                for (let key in data["customData"]) {
                    if (data["customData"].hasOwnProperty(key))
                        this.customData[key] = data["customData"][key];
                }
            }
            if (data["paymentMethods"] && data["paymentMethods"].constructor === Array) {
                this.paymentMethods = [];
                for (let item of data["paymentMethods"])
                    this.paymentMethods.push(PaymentOption.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateSubscriptionCompanyRequest {
        let result = new UpdateSubscriptionCompanyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["logoPath"] = this.logoPath;
        data["name"] = this.name;
        data["legalName"] = this.legalName;
        data["lineOfBusiness"] = this.lineOfBusiness;
        data["taxCode"] = this.taxCode;
        data["taxOffice"] = this.taxOffice;
        data["currencyCode"] = this.currencyCode;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["email"] = this.email;
        data["website"] = this.website;
        data["notes"] = this.notes;
        if (this.customData) {
            data["customData"] = {};
            for (let key in this.customData) {
                if (this.customData.hasOwnProperty(key))
                    data["customData"][key] = this.customData[key];
            }
        }
        if (this.paymentMethods && this.paymentMethods.constructor === Array) {
            data["paymentMethods"] = [];
            for (let item of this.paymentMethods)
                data["paymentMethods"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UpdateSubscriptionCompanyRequest();
        result.init(json);
        return result;
    }
}

export class UpdateContactRequest {
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    address?: Address | undefined;
    phone1?: string | undefined;
    phone2?: string | undefined;
    skype?: string | undefined;
    notes?: string | undefined;

    init(data?: any) {
        if (data) {
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.address = data["address"] ? Address.fromJS(data["address"]) : <any>undefined;
            this.phone1 = data["phone1"];
            this.phone2 = data["phone2"];
            this.skype = data["skype"];
            this.notes = data["notes"];
        }
    }

    static fromJS(data: any): UpdateContactRequest {
        let result = new UpdateContactRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["phone1"] = this.phone1;
        data["phone2"] = this.phone2;
        data["skype"] = this.skype;
        data["notes"] = this.notes;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UpdateContactRequest();
        result.init(json);
        return result;
    }
}

export class ResultSetOfContactInfo {
    count?: number | undefined;
    items?: Contact[] | undefined;

    init(data?: any) {
        if (data) {
            this.count = data["count"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Contact.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultSetOfContactInfo {
        let result = new ResultSetOfContactInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ResultSetOfContactInfo();
        result.init(json);
        return result;
    }
}

export class ResultSetOfOrganisationInfo {
    count?: number | undefined;
    items?: Organisation[] | undefined;

    init(data?: any) {
        if (data) {
            this.count = data["count"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Organisation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultSetOfOrganisationInfo {
        let result = new ResultSetOfOrganisationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ResultSetOfOrganisationInfo();
        result.init(json);
        return result;
    }
}

export class ResultSetOfInvoiceInfo {
    count?: number | undefined;
    items?: Invoice[] | undefined;

    init(data?: any) {
        if (data) {
            this.count = data["count"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Invoice.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultSetOfInvoiceInfo {
        let result = new ResultSetOfInvoiceInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ResultSetOfInvoiceInfo();
        result.init(json);
        return result;
    }
}

export class Invoice {
    id?: string | undefined;
    typeId?: string | undefined;
    number?: number | undefined;
    numberPrintable?: string | undefined;
    date?: Date | undefined;
    dueDate?: Date | undefined;
    status?: InvoiceStatus | undefined;
    currencyCode?: string | undefined;
    currencyRate?: number | undefined;
    recipient?: Recipient | undefined;
    paymentCode?: string | undefined;
    lines?: InvoiceLine[] | undefined;
    notes?: string | undefined;
    publicNotes?: string | undefined;
    tags?: string | undefined;
    readonly permaLink?: string | undefined;
    subTotal?: number | undefined;
    totalSalesTax?: number | undefined;
    totalTax?: number | undefined;
    total?: number | undefined;
    totalPayable?: number | undefined;

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.typeId = data["typeId"];
            this.number = data["number"];
            this.numberPrintable = data["numberPrintable"];
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>undefined;
            this.dueDate = data["dueDate"] ? new Date(data["dueDate"].toString()) : <any>undefined;
            this.status = data["status"];
            this.currencyCode = data["currencyCode"];
            this.currencyRate = data["currencyRate"];
            this.recipient = data["recipient"] ? Recipient.fromJS(data["recipient"]) : <any>undefined;
            this.paymentCode = data["paymentCode"];
            if (data["lines"] && data["lines"].constructor === Array) {
                this.lines = [];
                for (let item of data["lines"])
                    this.lines.push(InvoiceLine.fromJS(item));
            }
            this.notes = data["notes"];
            this.publicNotes = data["publicNotes"];
            this.tags = data["tags"];
            (<any>this).permaLink = data["permaLink"];
            this.subTotal = data["subTotal"];
            this.totalSalesTax = data["totalSalesTax"];
            this.totalTax = data["totalTax"];
            this.total = data["total"];
            this.totalPayable = data["totalPayable"];
        }
    }

    static fromJS(data: any): Invoice {
        let result = new Invoice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeId"] = this.typeId;
        data["number"] = this.number;
        data["numberPrintable"] = this.numberPrintable;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["currencyCode"] = this.currencyCode;
        data["currencyRate"] = this.currencyRate;
        data["recipient"] = this.recipient ? this.recipient.toJSON() : <any>undefined;
        data["paymentCode"] = this.paymentCode;
        if (this.lines && this.lines.constructor === Array) {
            data["lines"] = [];
            for (let item of this.lines)
                data["lines"].push(item.toJSON());
        }
        data["notes"] = this.notes;
        data["publicNotes"] = this.publicNotes;
        data["tags"] = this.tags;
        data["permaLink"] = this.permaLink;
        data["subTotal"] = this.subTotal;
        data["totalSalesTax"] = this.totalSalesTax;
        data["totalTax"] = this.totalTax;
        data["total"] = this.total;
        data["totalPayable"] = this.totalPayable;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Invoice();
        result.init(json);
        return result;
    }
}

export class Recipient {
    organisation?: Organisation | undefined;
    contact?: Contact | undefined;

    init(data?: any) {
        if (data) {
            this.organisation = data["organisation"] ? Organisation.fromJS(data["organisation"]) : <any>undefined;
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Recipient {
        let result = new Recipient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organisation"] = this.organisation ? this.organisation.toJSON() : <any>undefined;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Recipient();
        result.init(json);
        return result;
    }
}

export class InvoiceLine {
    id?: string | undefined;
    product?: Product | undefined;
    description?: string | undefined;
    quantity?: number | undefined;
    unitAmount?: number | undefined;
    discountRate?: number | undefined;
    subTotal?: number | undefined;
    totalTax?: number | undefined;
    totalSalesTax?: number | undefined;
    total?: number | undefined;
    taxes?: Tax[] | undefined;
    readonly taxesDescription?: string | undefined;
    notes?: string | undefined;
    tags?: string | undefined;

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.product = data["product"] ? Product.fromJS(data["product"]) : <any>undefined;
            this.description = data["description"];
            this.quantity = data["quantity"];
            this.unitAmount = data["unitAmount"];
            this.discountRate = data["discountRate"];
            this.subTotal = data["subTotal"];
            this.totalTax = data["totalTax"];
            this.totalSalesTax = data["totalSalesTax"];
            this.total = data["total"];
            if (data["taxes"] && data["taxes"].constructor === Array) {
                this.taxes = [];
                for (let item of data["taxes"])
                    this.taxes.push(Tax.fromJS(item));
            }
            (<any>this).taxesDescription = data["taxesDescription"];
            this.notes = data["notes"];
            this.tags = data["tags"];
        }
    }

    static fromJS(data: any): InvoiceLine {
        let result = new InvoiceLine();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["quantity"] = this.quantity;
        data["unitAmount"] = this.unitAmount;
        data["discountRate"] = this.discountRate;
        data["subTotal"] = this.subTotal;
        data["totalTax"] = this.totalTax;
        data["totalSalesTax"] = this.totalSalesTax;
        data["total"] = this.total;
        if (this.taxes && this.taxes.constructor === Array) {
            data["taxes"] = [];
            for (let item of this.taxes)
                data["taxes"].push(item.toJSON());
        }
        data["taxesDescription"] = this.taxesDescription;
        data["notes"] = this.notes;
        data["tags"] = this.tags;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new InvoiceLine();
        result.init(json);
        return result;
    }
}

export class Product {
    id?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    amount?: number | undefined;
    taxes?: Tax[] | undefined;
    notes?: string | undefined;
    publicNotes?: string | undefined;
    tags?: string | undefined;

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.code = data["code"];
            this.name = data["name"];
            this.amount = data["amount"];
            if (data["taxes"] && data["taxes"].constructor === Array) {
                this.taxes = [];
                for (let item of data["taxes"])
                    this.taxes.push(Tax.fromJS(item));
            }
            this.notes = data["notes"];
            this.publicNotes = data["publicNotes"];
            this.tags = data["tags"];
        }
    }

    static fromJS(data: any): Product {
        let result = new Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["amount"] = this.amount;
        if (this.taxes && this.taxes.constructor === Array) {
            data["taxes"] = [];
            for (let item of this.taxes)
                data["taxes"].push(item.toJSON());
        }
        data["notes"] = this.notes;
        data["publicNotes"] = this.publicNotes;
        data["tags"] = this.tags;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Product();
        result.init(json);
        return result;
    }
}

export class Tax {
    type?: TaxType | undefined;
    code?: string | undefined;
    name?: string | undefined;
    rate?: number | undefined;
    inclusive?: boolean | undefined;
    isSalesTax?: boolean | undefined;
    amount?: number | undefined;

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.code = data["code"];
            this.name = data["name"];
            this.rate = data["rate"];
            this.inclusive = data["inclusive"];
            this.isSalesTax = data["isSalesTax"];
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): Tax {
        let result = new Tax();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["code"] = this.code;
        data["name"] = this.name;
        data["rate"] = this.rate;
        data["inclusive"] = this.inclusive;
        data["isSalesTax"] = this.isSalesTax;
        data["amount"] = this.amount;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Tax();
        result.init(json);
        return result;
    }
}

export class CreateInvoiceRequest {
    typeId?: string | undefined;
    number?: number | undefined;
    date?: Date | undefined;
    dueDate?: Date | undefined;
    status?: CreateInvoiceRequestStatus | undefined;
    currencyCode?: string | undefined;
    currencyRate?: number | undefined;
    recipient: Recipient = new Recipient();
    paymentCode?: string | undefined;
    lines: InvoiceLine[] = [];
    serverCalculations?: boolean | undefined;
    notes?: string | undefined;
    publicNotes?: string | undefined;
    tags?: string | undefined;
    subTotal?: number | undefined;
    totalSalesTax?: number | undefined;
    totalTax?: number | undefined;
    total?: number | undefined;
    totalPayable?: number | undefined;

    init(data?: any) {
        if (data) {
            this.typeId = data["typeId"];
            this.number = data["number"];
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>undefined;
            this.dueDate = data["dueDate"] ? new Date(data["dueDate"].toString()) : <any>undefined;
            this.status = data["status"];
            this.currencyCode = data["currencyCode"];
            this.currencyRate = data["currencyRate"];
            this.recipient = data["recipient"] ? Recipient.fromJS(data["recipient"]) : new Recipient();
            this.paymentCode = data["paymentCode"];
            if (data["lines"] && data["lines"].constructor === Array) {
                this.lines = [];
                for (let item of data["lines"])
                    this.lines.push(InvoiceLine.fromJS(item));
            }
            this.serverCalculations = data["serverCalculations"];
            this.notes = data["notes"];
            this.publicNotes = data["publicNotes"];
            this.tags = data["tags"];
            this.subTotal = data["subTotal"];
            this.totalSalesTax = data["totalSalesTax"];
            this.totalTax = data["totalTax"];
            this.total = data["total"];
            this.totalPayable = data["totalPayable"];
        }
    }

    static fromJS(data: any): CreateInvoiceRequest {
        let result = new CreateInvoiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["number"] = this.number;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["currencyCode"] = this.currencyCode;
        data["currencyRate"] = this.currencyRate;
        data["recipient"] = this.recipient ? this.recipient.toJSON() : <any>undefined;
        data["paymentCode"] = this.paymentCode;
        if (this.lines && this.lines.constructor === Array) {
            data["lines"] = [];
            for (let item of this.lines)
                data["lines"].push(item.toJSON());
        }
        data["serverCalculations"] = this.serverCalculations;
        data["notes"] = this.notes;
        data["publicNotes"] = this.publicNotes;
        data["tags"] = this.tags;
        data["subTotal"] = this.subTotal;
        data["totalSalesTax"] = this.totalSalesTax;
        data["totalTax"] = this.totalTax;
        data["total"] = this.total;
        data["totalPayable"] = this.totalPayable;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CreateInvoiceRequest();
        result.init(json);
        return result;
    }
}

export class UpdateInvoiceRequest {
    number?: number | undefined;
    date?: Date | undefined;
    dueDate?: Date | undefined;
    currencyCode?: string | undefined;
    currencyRate?: number | undefined;
    recipient?: Recipient | undefined;
    paymentCode?: string | undefined;
    lines: InvoiceLine[] = [];
    serverCalculations?: boolean | undefined;
    notes?: string | undefined;
    publicNotes?: string | undefined;
    tags?: string | undefined;
    subTotal?: number | undefined;
    totalSalesTax?: number | undefined;
    totalTax?: number | undefined;
    total?: number | undefined;
    totalPayable?: number | undefined;

    init(data?: any) {
        if (data) {
            this.number = data["number"];
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>undefined;
            this.dueDate = data["dueDate"] ? new Date(data["dueDate"].toString()) : <any>undefined;
            this.currencyCode = data["currencyCode"];
            this.currencyRate = data["currencyRate"];
            this.recipient = data["recipient"] ? Recipient.fromJS(data["recipient"]) : <any>undefined;
            this.paymentCode = data["paymentCode"];
            if (data["lines"] && data["lines"].constructor === Array) {
                this.lines = [];
                for (let item of data["lines"])
                    this.lines.push(InvoiceLine.fromJS(item));
            }
            this.serverCalculations = data["serverCalculations"];
            this.notes = data["notes"];
            this.publicNotes = data["publicNotes"];
            this.tags = data["tags"];
            this.subTotal = data["subTotal"];
            this.totalSalesTax = data["totalSalesTax"];
            this.totalTax = data["totalTax"];
            this.total = data["total"];
            this.totalPayable = data["totalPayable"];
        }
    }

    static fromJS(data: any): UpdateInvoiceRequest {
        let result = new UpdateInvoiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["currencyCode"] = this.currencyCode;
        data["currencyRate"] = this.currencyRate;
        data["recipient"] = this.recipient ? this.recipient.toJSON() : <any>undefined;
        data["paymentCode"] = this.paymentCode;
        if (this.lines && this.lines.constructor === Array) {
            data["lines"] = [];
            for (let item of this.lines)
                data["lines"].push(item.toJSON());
        }
        data["serverCalculations"] = this.serverCalculations;
        data["notes"] = this.notes;
        data["publicNotes"] = this.publicNotes;
        data["tags"] = this.tags;
        data["subTotal"] = this.subTotal;
        data["totalSalesTax"] = this.totalSalesTax;
        data["totalTax"] = this.totalTax;
        data["total"] = this.total;
        data["totalPayable"] = this.totalPayable;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UpdateInvoiceRequest();
        result.init(json);
        return result;
    }
}

export class InvoiceStatusResponse {
    status?: InvoiceStatusResponseStatus | undefined;

    init(data?: any) {
        if (data) {
            this.status = data["status"];
        }
    }

    static fromJS(data: any): InvoiceStatusResponse {
        let result = new InvoiceStatusResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new InvoiceStatusResponse();
        result.init(json);
        return result;
    }
}

export class ChangeInvoiceStatusRequest {
    status?: ChangeInvoiceStatusRequestStatus | undefined;
    validationRules?: boolean | undefined;

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.validationRules = data["validationRules"];
        }
    }

    static fromJS(data: any): ChangeInvoiceStatusRequest {
        let result = new ChangeInvoiceStatusRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["validationRules"] = this.validationRules;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ChangeInvoiceStatusRequest();
        result.init(json);
        return result;
    }
}

export class InvoiceTrackingRequest {
    recipient: string;

    init(data?: any) {
        if (data) {
            this.recipient = data["recipient"];
        }
    }

    static fromJS(data: any): InvoiceTrackingRequest {
        let result = new InvoiceTrackingRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recipient"] = this.recipient;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new InvoiceTrackingRequest();
        result.init(json);
        return result;
    }
}

export class Tracker {
    id?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
    documentUrl?: string | undefined;

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.type = data["type"];
            this.url = data["url"];
            this.documentUrl = data["documentUrl"];
        }
    }

    static fromJS(data: any): Tracker {
        let result = new Tracker();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["url"] = this.url;
        data["documentUrl"] = this.documentUrl;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Tracker();
        result.init(json);
        return result;
    }
}

export class ResultSetOfTrackingInfo {
    count?: number | undefined;
    items?: Tracking[] | undefined;

    init(data?: any) {
        if (data) {
            this.count = data["count"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Tracking.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultSetOfTrackingInfo {
        let result = new ResultSetOfTrackingInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ResultSetOfTrackingInfo();
        result.init(json);
        return result;
    }
}

export class Tracking {
    reads?: number | undefined;
    recipient?: string | undefined;
    created?: Date | undefined;
    lastRead?: Date | undefined;
    tracker?: Tracker | undefined;

    init(data?: any) {
        if (data) {
            this.reads = data["reads"];
            this.recipient = data["recipient"];
            this.created = data["created"] ? new Date(data["created"].toString()) : <any>undefined;
            this.lastRead = data["lastRead"] ? new Date(data["lastRead"].toString()) : <any>undefined;
            this.tracker = data["tracker"] ? Tracker.fromJS(data["tracker"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Tracking {
        let result = new Tracking();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reads"] = this.reads;
        data["recipient"] = this.recipient;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastRead"] = this.lastRead ? this.lastRead.toISOString() : <any>undefined;
        data["tracker"] = this.tracker ? this.tracker.toJSON() : <any>undefined;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Tracking();
        result.init(json);
        return result;
    }
}

export class InvoiceType {
    id?: string | undefined;
    code?: string | undefined;
    recordType?: InvoiceTypeRecordType | undefined;
    name?: string | undefined;
    culture?: string | undefined;
    numberOffset?: number | undefined;
    numberFormat?: string | undefined;
    template?: Attachment | undefined;
    notes?: string | undefined;
    tags?: string | undefined;
    generatesDocuments?: boolean | undefined;

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.code = data["code"];
            this.recordType = data["recordType"];
            this.name = data["name"];
            this.culture = data["culture"];
            this.numberOffset = data["numberOffset"];
            this.numberFormat = data["numberFormat"];
            this.template = data["template"] ? Attachment.fromJS(data["template"]) : <any>undefined;
            this.notes = data["notes"];
            this.tags = data["tags"];
            this.generatesDocuments = data["generatesDocuments"];
        }
    }

    static fromJS(data: any): InvoiceType {
        let result = new InvoiceType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["recordType"] = this.recordType;
        data["name"] = this.name;
        data["culture"] = this.culture;
        data["numberOffset"] = this.numberOffset;
        data["numberFormat"] = this.numberFormat;
        data["template"] = this.template ? this.template.toJSON() : <any>undefined;
        data["notes"] = this.notes;
        data["tags"] = this.tags;
        data["generatesDocuments"] = this.generatesDocuments;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new InvoiceType();
        result.init(json);
        return result;
    }
}

export class Attachment {
    id?: string | undefined;
    guid?: string | undefined;
    name?: string | undefined;
    fileExtension?: string | undefined;
    contentType?: string | undefined;
    contentLength?: number | undefined;
    data?: string | undefined;
    readonly uri?: string | undefined;

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.guid = data["guid"];
            this.name = data["name"];
            this.fileExtension = data["fileExtension"];
            this.contentType = data["contentType"];
            this.contentLength = data["contentLength"];
            this.data = data["data"];
            (<any>this).uri = data["uri"];
        }
    }

    static fromJS(data: any): Attachment {
        let result = new Attachment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["guid"] = this.guid;
        data["name"] = this.name;
        data["fileExtension"] = this.fileExtension;
        data["contentType"] = this.contentType;
        data["contentLength"] = this.contentLength;
        data["data"] = this.data;
        data["uri"] = this.uri;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Attachment();
        result.init(json);
        return result;
    }
}

export class ChangeInvoiceTypeRequest {
    typeId?: string | undefined;

    init(data?: any) {
        if (data) {
            this.typeId = data["typeId"];
        }
    }

    static fromJS(data: any): ChangeInvoiceTypeRequest {
        let result = new ChangeInvoiceTypeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ChangeInvoiceTypeRequest();
        result.init(json);
        return result;
    }
}

export class ResultSetOfInvoiceType {
    count?: number | undefined;
    items?: InvoiceType[] | undefined;

    init(data?: any) {
        if (data) {
            this.count = data["count"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(InvoiceType.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultSetOfInvoiceType {
        let result = new ResultSetOfInvoiceType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ResultSetOfInvoiceType();
        result.init(json);
        return result;
    }
}

export class CreateInvoiceTypeRequest {
    name: string;
    code?: string | undefined;
    culture?: string | undefined;
    numberOffset?: number | undefined;
    recordType?: CreateInvoiceTypeRequestRecordType | undefined;
    numberFormat?: string | undefined;
    tags?: string | undefined;
    notes?: string | undefined;
    generatesDocuments?: boolean | undefined;

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.code = data["code"];
            this.culture = data["culture"];
            this.numberOffset = data["numberOffset"];
            this.recordType = data["recordType"];
            this.numberFormat = data["numberFormat"];
            this.tags = data["tags"];
            this.notes = data["notes"];
            this.generatesDocuments = data["generatesDocuments"];
        }
    }

    static fromJS(data: any): CreateInvoiceTypeRequest {
        let result = new CreateInvoiceTypeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["culture"] = this.culture;
        data["numberOffset"] = this.numberOffset;
        data["recordType"] = this.recordType;
        data["numberFormat"] = this.numberFormat;
        data["tags"] = this.tags;
        data["notes"] = this.notes;
        data["generatesDocuments"] = this.generatesDocuments;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CreateInvoiceTypeRequest();
        result.init(json);
        return result;
    }
}

export class UpdateInvoiceTypeRequest {
    name: string;
    code?: string | undefined;
    culture?: string | undefined;
    numberOffset?: number | undefined;
    recordType?: UpdateInvoiceTypeRequestRecordType | undefined;
    numberFormat?: string | undefined;
    tags?: string | undefined;
    notes?: string | undefined;
    generatesDocuments?: boolean | undefined;

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.code = data["code"];
            this.culture = data["culture"];
            this.numberOffset = data["numberOffset"];
            this.recordType = data["recordType"];
            this.numberFormat = data["numberFormat"];
            this.tags = data["tags"];
            this.notes = data["notes"];
            this.generatesDocuments = data["generatesDocuments"];
        }
    }

    static fromJS(data: any): UpdateInvoiceTypeRequest {
        let result = new UpdateInvoiceTypeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["culture"] = this.culture;
        data["numberOffset"] = this.numberOffset;
        data["recordType"] = this.recordType;
        data["numberFormat"] = this.numberFormat;
        data["tags"] = this.tags;
        data["notes"] = this.notes;
        data["generatesDocuments"] = this.generatesDocuments;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UpdateInvoiceTypeRequest();
        result.init(json);
        return result;
    }
}

export class ResultSetOfMetricsRecord {
    summary?: Metrics | undefined;
    count?: number | undefined;
    items?: MetricsRecord[] | undefined;

    init(data?: any) {
        if (data) {
            this.summary = data["summary"] ? Metrics.fromJS(data["summary"]) : <any>undefined;
            this.count = data["count"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(MetricsRecord.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultSetOfMetricsRecord {
        let result = new ResultSetOfMetricsRecord();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["summary"] = this.summary ? this.summary.toJSON() : <any>undefined;
        data["count"] = this.count;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ResultSetOfMetricsRecord();
        result.init(json);
        return result;
    }
}

export class Metrics {
    requests?: number | undefined;
    requestsPerMinute?: number | undefined;
    writes?: number | undefined;
    reads?: number | undefined;
    invoiced?: number | undefined;

    init(data?: any) {
        if (data) {
            this.requests = data["requests"];
            this.requestsPerMinute = data["requestsPerMinute"];
            this.writes = data["writes"];
            this.reads = data["reads"];
            this.invoiced = data["invoiced"];
        }
    }

    static fromJS(data: any): Metrics {
        let result = new Metrics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requests"] = this.requests;
        data["requestsPerMinute"] = this.requestsPerMinute;
        data["writes"] = this.writes;
        data["reads"] = this.reads;
        data["invoiced"] = this.invoiced;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Metrics();
        result.init(json);
        return result;
    }
}

export class MetricsRecord {
    timestamp?: Date | undefined;
    period?: string | undefined;
    metrics?: Metrics | undefined;

    init(data?: any) {
        if (data) {
            this.timestamp = data["timestamp"] ? new Date(data["timestamp"].toString()) : <any>undefined;
            this.period = data["period"];
            this.metrics = data["metrics"] ? Metrics.fromJS(data["metrics"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MetricsRecord {
        let result = new MetricsRecord();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["period"] = this.period;
        data["metrics"] = this.metrics ? this.metrics.toJSON() : <any>undefined;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new MetricsRecord();
        result.init(json);
        return result;
    }
}

export class UpdateOrganisationRequest {
    code?: string | undefined;
    logoPath?: string | undefined;
    name: string;
    legalName?: string | undefined;
    lineOfBusiness?: string | undefined;
    taxCode?: string | undefined;
    taxOffice?: string | undefined;
    currencyCode?: string | undefined;
    address?: Address | undefined;
    email?: string | undefined;
    website?: string | undefined;
    notes?: string | undefined;
    customData?: any | undefined;
    paymentMethods?: PaymentOption[] | undefined;

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.logoPath = data["logoPath"];
            this.name = data["name"];
            this.legalName = data["legalName"];
            this.lineOfBusiness = data["lineOfBusiness"];
            this.taxCode = data["taxCode"];
            this.taxOffice = data["taxOffice"];
            this.currencyCode = data["currencyCode"];
            this.address = data["address"] ? Address.fromJS(data["address"]) : <any>undefined;
            this.email = data["email"];
            this.website = data["website"];
            this.notes = data["notes"];
            if (data["customData"]) {
                this.customData = {};
                for (let key in data["customData"]) {
                    if (data["customData"].hasOwnProperty(key))
                        this.customData[key] = data["customData"][key];
                }
            }
            if (data["paymentMethods"] && data["paymentMethods"].constructor === Array) {
                this.paymentMethods = [];
                for (let item of data["paymentMethods"])
                    this.paymentMethods.push(PaymentOption.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateOrganisationRequest {
        let result = new UpdateOrganisationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["logoPath"] = this.logoPath;
        data["name"] = this.name;
        data["legalName"] = this.legalName;
        data["lineOfBusiness"] = this.lineOfBusiness;
        data["taxCode"] = this.taxCode;
        data["taxOffice"] = this.taxOffice;
        data["currencyCode"] = this.currencyCode;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["email"] = this.email;
        data["website"] = this.website;
        data["notes"] = this.notes;
        if (this.customData) {
            data["customData"] = {};
            for (let key in this.customData) {
                if (this.customData.hasOwnProperty(key))
                    data["customData"][key] = this.customData[key];
            }
        }
        if (this.paymentMethods && this.paymentMethods.constructor === Array) {
            data["paymentMethods"] = [];
            for (let item of this.paymentMethods)
                data["paymentMethods"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UpdateOrganisationRequest();
        result.init(json);
        return result;
    }
}

export class ResultSetOfProductInfo {
    count?: number | undefined;
    items?: Product[] | undefined;

    init(data?: any) {
        if (data) {
            this.count = data["count"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Product.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultSetOfProductInfo {
        let result = new ResultSetOfProductInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ResultSetOfProductInfo();
        result.init(json);
        return result;
    }
}

export class UpdateSubscriptionStatusRequest {
    status?: UpdateSubscriptionStatusRequestStatus | undefined;

    init(data?: any) {
        if (data) {
            this.status = data["status"];
        }
    }

    static fromJS(data: any): UpdateSubscriptionStatusRequest {
        let result = new UpdateSubscriptionStatusRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UpdateSubscriptionStatusRequest();
        result.init(json);
        return result;
    }
}

export class UpdateSubscriptionTimeZoneRequest {
    timeZone?: string | undefined;

    init(data?: any) {
        if (data) {
            this.timeZone = data["timeZone"];
        }
    }

    static fromJS(data: any): UpdateSubscriptionTimeZoneRequest {
        let result = new UpdateSubscriptionTimeZoneRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZone"] = this.timeZone;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UpdateSubscriptionTimeZoneRequest();
        result.init(json);
        return result;
    }
}

export enum Status {
    Draft = <any>"Draft", 
    Issued = <any>"Issued", 
    Overdue = <any>"Overdue", 
    Partial = <any>"Partial", 
    Paid = <any>"Paid", 
    Void = <any>"Void", 
    Deleted = <any>"Deleted", 
}

export enum SubscriptionStatus {
    Enabled = <any>"Enabled", 
    Disabled = <any>"Disabled", 
    Deleted = <any>"Deleted", 
}

export enum PaymentOptionType {
    BankTransfer = <any>"BankTransfer", 
    Online = <any>"Online", 
    UponDelivery = <any>"UponDelivery", 
}

export enum CreateSubscriptionRequestType {
    Sandbox = <any>"Sandbox", 
    Trial = <any>"Trial", 
    Basic = <any>"Basic", 
    Pro = <any>"Pro", 
    Custom = <any>"Custom", 
}

export enum BankTransactionType {
    Credit = <any>"Credit", 
    Debit = <any>"Debit", 
}

export enum PaymentApproval {
    Pending = <any>"Pending", 
    Approved = <any>"Approved", 
    Rejected = <any>"Rejected", 
}

export enum InvoiceStatus {
    Draft = <any>"Draft", 
    Issued = <any>"Issued", 
    Overdue = <any>"Overdue", 
    Partial = <any>"Partial", 
    Paid = <any>"Paid", 
    Void = <any>"Void", 
    Deleted = <any>"Deleted", 
}

export enum TaxType {
    UnitRate = <any>"UnitRate", 
    FixedRate = <any>"FixedRate", 
    Fixed = <any>"Fixed", 
}

export enum CreateInvoiceRequestStatus {
    Draft = <any>"Draft", 
    Issued = <any>"Issued", 
    Overdue = <any>"Overdue", 
    Partial = <any>"Partial", 
    Paid = <any>"Paid", 
    Void = <any>"Void", 
    Deleted = <any>"Deleted", 
}

export enum InvoiceStatusResponseStatus {
    Draft = <any>"Draft", 
    Issued = <any>"Issued", 
    Overdue = <any>"Overdue", 
    Partial = <any>"Partial", 
    Paid = <any>"Paid", 
    Void = <any>"Void", 
    Deleted = <any>"Deleted", 
}

export enum ChangeInvoiceStatusRequestStatus {
    Draft = <any>"Draft", 
    Issued = <any>"Issued", 
    Overdue = <any>"Overdue", 
    Partial = <any>"Partial", 
    Paid = <any>"Paid", 
    Void = <any>"Void", 
    Deleted = <any>"Deleted", 
}

export enum InvoiceTypeRecordType {
    AccountsReceivable = <any>"AccountsReceivable", 
    AccountsPayable = <any>"AccountsPayable", 
}

export enum CreateInvoiceTypeRequestRecordType {
    AccountsReceivable = <any>"AccountsReceivable", 
    AccountsPayable = <any>"AccountsPayable", 
}

export enum UpdateInvoiceTypeRequestRecordType {
    AccountsReceivable = <any>"AccountsReceivable", 
    AccountsPayable = <any>"AccountsPayable", 
}

export enum UpdateSubscriptionStatusRequestStatus {
    Enabled = <any>"Enabled", 
    Disabled = <any>"Disabled", 
    Deleted = <any>"Deleted", 
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}