/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.12.7.0 (NJsonSchema v9.10.6.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { Http, Headers, ResponseContentType, Response } from '@angular/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class ApiClient {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://api.incontrl.io";
    }

    /**
     * @page (optional) 
     * @size (optional) 
     * @sort (optional) 
     * @search (optional) 
     * @return Success
     */
    getLookup(lookupType: string, page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfLookupEntry> {
        let url_ = this.baseUrl + "/{lookupType}/lookup?";
        if (lookupType === undefined || lookupType === null)
            throw new Error("The parameter 'lookupType' must be defined.");
        url_ = url_.replace("{lookupType}", encodeURIComponent("" + lookupType)); 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetLookup(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetLookup(response_);
                } catch (e) {
                    return <Observable<ResultSetOfLookupEntry>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfLookupEntry>><any>Observable.throw(response_);
        });
    }

    protected processGetLookup(response: Response): Observable<ResultSetOfLookupEntry> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfLookupEntry.fromJS(resultData200) : new ResultSetOfLookupEntry();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfLookupEntry>(<any>null);
    }

    /**
     * @page (optional) 
     * @size (optional) 
     * @sort (optional) 
     * @search (optional) 
     * @return Success
     */
    getCountries(page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfCountryInfo> {
        let url_ = this.baseUrl + "/countries?";
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetCountries(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetCountries(response_);
                } catch (e) {
                    return <Observable<ResultSetOfCountryInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfCountryInfo>><any>Observable.throw(response_);
        });
    }

    protected processGetCountries(response: Response): Observable<ResultSetOfCountryInfo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfCountryInfo.fromJS(resultData200) : new ResultSetOfCountryInfo();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfCountryInfo>(<any>null);
    }

    /**
     * @page (optional) 
     * @size (optional) 
     * @sort (optional) 
     * @search (optional) 
     * @return Success
     */
    getCurrencies(page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfCurrencyInfo> {
        let url_ = this.baseUrl + "/currencies?";
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetCurrencies(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetCurrencies(response_);
                } catch (e) {
                    return <Observable<ResultSetOfCurrencyInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfCurrencyInfo>><any>Observable.throw(response_);
        });
    }

    protected processGetCurrencies(response: Response): Observable<ResultSetOfCurrencyInfo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfCurrencyInfo.fromJS(resultData200) : new ResultSetOfCurrencyInfo();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfCurrencyInfo>(<any>null);
    }

    /**
     * @filter_Code (optional) 
     * @filter_MemberId (optional) 
     * @page (optional) 
     * @size (optional) 
     * @sort (optional) 
     * @search (optional) 
     * @return Success
     */
    getSubscriptions(filter_Code?: string | null, filter_MemberId?: string | null, page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfSubscriptionInfo> {
        let url_ = this.baseUrl + "/subscriptions?";
        if (filter_Code !== undefined)
            url_ += "Filter.Code=" + encodeURIComponent("" + filter_Code) + "&"; 
        if (filter_MemberId !== undefined)
            url_ += "Filter.MemberId=" + encodeURIComponent("" + filter_MemberId) + "&"; 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetSubscriptions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetSubscriptions(response_);
                } catch (e) {
                    return <Observable<ResultSetOfSubscriptionInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfSubscriptionInfo>><any>Observable.throw(response_);
        });
    }

    protected processGetSubscriptions(response: Response): Observable<ResultSetOfSubscriptionInfo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfSubscriptionInfo.fromJS(resultData200) : new ResultSetOfSubscriptionInfo();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfSubscriptionInfo>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    createSubscription(request?: CreateSubscriptionRequest | null): Observable<Subscription> {
        let url_ = this.baseUrl + "/subscriptions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateSubscription(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateSubscription(response_);
                } catch (e) {
                    return <Observable<Subscription>><any>Observable.throw(e);
                }
            } else
                return <Observable<Subscription>><any>Observable.throw(response_);
        });
    }

    protected processCreateSubscription(response: Response): Observable<Subscription> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Subscription.fromJS(resultData201) : new Subscription();
            return Observable.of(result201);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Subscription>(<any>null);
    }

    /**
     * Get a single subscription by id
     * @subscriptionId The subscription id to search for
     * @return Success
     */
    getSubscription(subscriptionId: string): Observable<Subscription> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetSubscription(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetSubscription(response_);
                } catch (e) {
                    return <Observable<Subscription>><any>Observable.throw(e);
                }
            } else
                return <Observable<Subscription>><any>Observable.throw(response_);
        });
    }

    protected processGetSubscription(response: Response): Observable<Subscription> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Subscription.fromJS(resultData200) : new Subscription();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Subscription>(<any>null);
    }

    /**
     * @return Success
     */
    getSubscriptionCompany(subscriptionId: string): Observable<Organisation> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/company";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetSubscriptionCompany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetSubscriptionCompany(response_);
                } catch (e) {
                    return <Observable<Organisation>><any>Observable.throw(e);
                }
            } else
                return <Observable<Organisation>><any>Observable.throw(response_);
        });
    }

    protected processGetSubscriptionCompany(response: Response): Observable<Organisation> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Organisation.fromJS(resultData200) : new Organisation();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Organisation>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    updateSubscriptionCompany(subscriptionId: string, request?: UpdateSubscriptionCompanyRequest | null): Observable<Organisation> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/company";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateSubscriptionCompany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateSubscriptionCompany(response_);
                } catch (e) {
                    return <Observable<Organisation>><any>Observable.throw(e);
                }
            } else
                return <Observable<Organisation>><any>Observable.throw(response_);
        });
    }

    protected processUpdateSubscriptionCompany(response: Response): Observable<Organisation> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Organisation.fromJS(resultData200) : new Organisation();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Organisation>(<any>null);
    }

    /**
     * @file (optional) 
     * @return Success
     */
    updateSubscriptionCompanyLogo(subscriptionId: string, file?: FileParameter | null): Observable<Link> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/company/logo";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateSubscriptionCompanyLogo(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateSubscriptionCompanyLogo(response_);
                } catch (e) {
                    return <Observable<Link>><any>Observable.throw(e);
                }
            } else
                return <Observable<Link>><any>Observable.throw(response_);
        });
    }

    protected processUpdateSubscriptionCompanyLogo(response: Response): Observable<Link> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Link.fromJS(resultData200) : new Link();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Link>(<any>null);
    }

    /**
     * @return Success
     */
    getSubscriptionContact(subscriptionId: string): Observable<Contact> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/contact";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetSubscriptionContact(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetSubscriptionContact(response_);
                } catch (e) {
                    return <Observable<Contact>><any>Observable.throw(e);
                }
            } else
                return <Observable<Contact>><any>Observable.throw(response_);
        });
    }

    protected processGetSubscriptionContact(response: Response): Observable<Contact> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Contact.fromJS(resultData200) : new Contact();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Contact>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    updateSubscriptionContact(subscriptionId: string, request?: UpdateContactRequest | null): Observable<Contact> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/contact";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateSubscriptionContact(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateSubscriptionContact(response_);
                } catch (e) {
                    return <Observable<Contact>><any>Observable.throw(e);
                }
            } else
                return <Observable<Contact>><any>Observable.throw(response_);
        });
    }

    protected processUpdateSubscriptionContact(response: Response): Observable<Contact> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Contact.fromJS(resultData200) : new Contact();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Contact>(<any>null);
    }

    /**
     * @filter_Code (optional) 
     * @page (optional) 
     * @size (optional) 
     * @sort (optional) 
     * @search (optional) 
     * @return Success
     */
    getContacts(subscriptionId: string, filter_Code?: string | null, page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfContactInfo> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/contacts?";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (filter_Code !== undefined)
            url_ += "Filter.Code=" + encodeURIComponent("" + filter_Code) + "&"; 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetContacts(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetContacts(response_);
                } catch (e) {
                    return <Observable<ResultSetOfContactInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfContactInfo>><any>Observable.throw(response_);
        });
    }

    protected processGetContacts(response: Response): Observable<ResultSetOfContactInfo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfContactInfo.fromJS(resultData200) : new ResultSetOfContactInfo();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfContactInfo>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    createContact(subscriptionId: string, request?: Contact | null): Observable<Contact> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/contacts";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateContact(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateContact(response_);
                } catch (e) {
                    return <Observable<Contact>><any>Observable.throw(e);
                }
            } else
                return <Observable<Contact>><any>Observable.throw(response_);
        });
    }

    protected processCreateContact(response: Response): Observable<Contact> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Contact.fromJS(resultData201) : new Contact();
            return Observable.of(result201);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Contact>(<any>null);
    }

    /**
     * @return Success
     */
    getContact(subscriptionId: string, contactId: string): Observable<Contact> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/contacts/{contactId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined.");
        url_ = url_.replace("{contactId}", encodeURIComponent("" + contactId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetContact(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetContact(response_);
                } catch (e) {
                    return <Observable<Contact>><any>Observable.throw(e);
                }
            } else
                return <Observable<Contact>><any>Observable.throw(response_);
        });
    }

    protected processGetContact(response: Response): Observable<Contact> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Contact.fromJS(resultData200) : new Contact();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Contact>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    updateContact(subscriptionId: string, contactId: string, request?: Contact | null): Observable<Contact> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/contacts/{contactId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined.");
        url_ = url_.replace("{contactId}", encodeURIComponent("" + contactId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateContact(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateContact(response_);
                } catch (e) {
                    return <Observable<Contact>><any>Observable.throw(e);
                }
            } else
                return <Observable<Contact>><any>Observable.throw(response_);
        });
    }

    protected processUpdateContact(response: Response): Observable<Contact> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Contact.fromJS(resultData200) : new Contact();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Contact>(<any>null);
    }

    /**
     * @filter_Customers (optional) 
     * @filter_Suppliers (optional) 
     * @filter_Code (optional) 
     * @page (optional) 
     * @size (optional) 
     * @sort (optional) 
     * @search (optional) 
     * @return Success
     */
    getCompaniesByContact(subscriptionId: string, contactId: string, filter_Customers?: boolean | null, filter_Suppliers?: boolean | null, filter_Code?: string | null, page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfOrganisationInfo> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/contacts/{contactId}/companies?";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined.");
        url_ = url_.replace("{contactId}", encodeURIComponent("" + contactId)); 
        if (filter_Customers !== undefined)
            url_ += "Filter.Customers=" + encodeURIComponent("" + filter_Customers) + "&"; 
        if (filter_Suppliers !== undefined)
            url_ += "Filter.Suppliers=" + encodeURIComponent("" + filter_Suppliers) + "&"; 
        if (filter_Code !== undefined)
            url_ += "Filter.Code=" + encodeURIComponent("" + filter_Code) + "&"; 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetCompaniesByContact(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetCompaniesByContact(response_);
                } catch (e) {
                    return <Observable<ResultSetOfOrganisationInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfOrganisationInfo>><any>Observable.throw(response_);
        });
    }

    protected processGetCompaniesByContact(response: Response): Observable<ResultSetOfOrganisationInfo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfOrganisationInfo.fromJS(resultData200) : new ResultSetOfOrganisationInfo();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfOrganisationInfo>(<any>null);
    }

    /**
     * @filter_Number (optional) 
     * @filter_From (optional) 
     * @filter_To (optional) 
     * @filter_Status (optional) 
     * @filter_RecipientCode (optional) 
     * @filter_RecipientId (optional) 
     * @filter_TypeId (optional) 
     * @filter_PaymentCode (optional) 
     * @page (optional) 
     * @size (optional) 
     * @sort (optional) 
     * @search (optional) 
     * @summary (optional) 
     * @return Success
     */
    getDocuments(subscriptionId: string, filter_Number?: string | null, filter_From?: Date | null, filter_To?: Date | null, filter_Status?: Status | null, filter_RecipientCode?: string | null, filter_RecipientId?: string | null, filter_TypeId?: string[] | null, filter_PaymentCode?: string | null, page?: number | null, size?: number | null, sort?: string | null, search?: string | null, summary?: boolean | null): Observable<ResultSetOfDocumentInfo> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/documents?";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (filter_Number !== undefined)
            url_ += "Filter.Number=" + encodeURIComponent("" + filter_Number) + "&"; 
        if (filter_From !== undefined)
            url_ += "Filter.From=" + encodeURIComponent(filter_From ? "" + filter_From.toJSON() : "") + "&"; 
        if (filter_To !== undefined)
            url_ += "Filter.To=" + encodeURIComponent(filter_To ? "" + filter_To.toJSON() : "") + "&"; 
        if (filter_Status !== undefined)
            url_ += "Filter.Status=" + encodeURIComponent("" + filter_Status) + "&"; 
        if (filter_RecipientCode !== undefined)
            url_ += "Filter.RecipientCode=" + encodeURIComponent("" + filter_RecipientCode) + "&"; 
        if (filter_RecipientId !== undefined)
            url_ += "Filter.RecipientId=" + encodeURIComponent("" + filter_RecipientId) + "&"; 
        if (filter_TypeId !== undefined)
            filter_TypeId && filter_TypeId.forEach(item => { url_ += "Filter.TypeId=" + encodeURIComponent("" + item) + "&"; });
        if (filter_PaymentCode !== undefined)
            url_ += "Filter.PaymentCode=" + encodeURIComponent("" + filter_PaymentCode) + "&"; 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        if (summary !== undefined)
            url_ += "summary=" + encodeURIComponent("" + summary) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetDocuments(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetDocuments(response_);
                } catch (e) {
                    return <Observable<ResultSetOfDocumentInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfDocumentInfo>><any>Observable.throw(response_);
        });
    }

    protected processGetDocuments(response: Response): Observable<ResultSetOfDocumentInfo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfDocumentInfo.fromJS(resultData200) : new ResultSetOfDocumentInfo();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfDocumentInfo>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    createDocument(subscriptionId: string, request?: CreateDocumentRequest | null): Observable<Document> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/documents";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateDocument(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateDocument(response_);
                } catch (e) {
                    return <Observable<Document>><any>Observable.throw(e);
                }
            } else
                return <Observable<Document>><any>Observable.throw(response_);
        });
    }

    protected processCreateDocument(response: Response): Observable<Document> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Document.fromJS(resultData201) : new Document();
            return Observable.of(result201);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Document>(<any>null);
    }

    /**
     * @format (optional) 
     * @return Success
     */
    getDocument(subscriptionId: string, documentId: string, format?: string | null): Observable<Document> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/documents/{documentId}?";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId)); 
        if (format !== undefined)
            url_ += "format=" + encodeURIComponent("" + format) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetDocument(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetDocument(response_);
                } catch (e) {
                    return <Observable<Document>><any>Observable.throw(e);
                }
            } else
                return <Observable<Document>><any>Observable.throw(response_);
        });
    }

    protected processGetDocument(response: Response): Observable<Document> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Document.fromJS(resultData200) : new Document();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Document>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    updateDocument(subscriptionId: string, documentId: string, request?: UpdateDocumentRequest | null): Observable<Document> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/documents/{documentId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateDocument(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateDocument(response_);
                } catch (e) {
                    return <Observable<Document>><any>Observable.throw(e);
                }
            } else
                return <Observable<Document>><any>Observable.throw(response_);
        });
    }

    protected processUpdateDocument(response: Response): Observable<Document> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Document.fromJS(resultData200) : new Document();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Document>(<any>null);
    }

    /**
     * @return Success
     */
    deleteDocument(subscriptionId: string, documentId: string): Observable<void> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/documents/{documentId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeleteDocument(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteDocument(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteDocument(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @page (optional) 
     * @size (optional) 
     * @sort (optional) 
     * @search (optional) 
     * @return Success
     */
    getDocumentPayments(subscriptionId: string, documentId: string, page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfPaymentInfo> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/documents/{documentId}/payments?";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId)); 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetDocumentPayments(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetDocumentPayments(response_);
                } catch (e) {
                    return <Observable<ResultSetOfPaymentInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfPaymentInfo>><any>Observable.throw(response_);
        });
    }

    protected processGetDocumentPayments(response: Response): Observable<ResultSetOfPaymentInfo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfPaymentInfo.fromJS(resultData200) : new ResultSetOfPaymentInfo();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfPaymentInfo>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    createDocumentPayment(subscriptionId: string, documentId: string, request?: Payment | null): Observable<Payment> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/documents/{documentId}/payments";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateDocumentPayment(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateDocumentPayment(response_);
                } catch (e) {
                    return <Observable<Payment>><any>Observable.throw(e);
                }
            } else
                return <Observable<Payment>><any>Observable.throw(response_);
        });
    }

    protected processCreateDocumentPayment(response: Response): Observable<Payment> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Payment.fromJS(resultData200) : new Payment();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Payment>(<any>null);
    }

    /**
     * @return Success
     */
    deleteDocumentPayment(subscriptionId: string, documentId: string, transactionId: string): Observable<void> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/documents/{documentId}/payments/{transactionId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId)); 
        if (transactionId === undefined || transactionId === null)
            throw new Error("The parameter 'transactionId' must be defined.");
        url_ = url_.replace("{transactionId}", encodeURIComponent("" + transactionId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeleteDocumentPayment(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteDocumentPayment(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteDocumentPayment(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @approval (optional) 
     * @return Success
     */
    updateDocumentPaymentApproval(subscriptionId: string, documentId: string, transactionId: string, approval?: UpdateApprovalRequest | null): Observable<void> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/documents/{documentId}/payments/{transactionId}/approval";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId)); 
        if (transactionId === undefined || transactionId === null)
            throw new Error("The parameter 'transactionId' must be defined.");
        url_ = url_.replace("{transactionId}", encodeURIComponent("" + transactionId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(approval);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateDocumentPaymentApproval(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateDocumentPaymentApproval(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateDocumentPaymentApproval(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getDocumentStatus(subscriptionId: string, documentId: string): Observable<DocumentStatusResponse> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/documents/{documentId}/status";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetDocumentStatus(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetDocumentStatus(response_);
                } catch (e) {
                    return <Observable<DocumentStatusResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<DocumentStatusResponse>><any>Observable.throw(response_);
        });
    }

    protected processGetDocumentStatus(response: Response): Observable<DocumentStatusResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentStatusResponse.fromJS(resultData200) : new DocumentStatusResponse();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DocumentStatusResponse>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    changeDocumentStatus(subscriptionId: string, documentId: string, request?: ChangeDocumentStatusRequest | null): Observable<DocumentStatusResponse> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/documents/{documentId}/status";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processChangeDocumentStatus(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processChangeDocumentStatus(response_);
                } catch (e) {
                    return <Observable<DocumentStatusResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<DocumentStatusResponse>><any>Observable.throw(response_);
        });
    }

    protected processChangeDocumentStatus(response: Response): Observable<DocumentStatusResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentStatusResponse.fromJS(resultData200) : new DocumentStatusResponse();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DocumentStatusResponse>(<any>null);
    }

    /**
     * @page (optional) 
     * @size (optional) 
     * @sort (optional) 
     * @search (optional) 
     * @return Success
     */
    getViews(subscriptionId: string, documentId: string, page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfTrackingInfo> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/documents/{documentId}/trackings?";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId)); 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetViews(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetViews(response_);
                } catch (e) {
                    return <Observable<ResultSetOfTrackingInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfTrackingInfo>><any>Observable.throw(response_);
        });
    }

    protected processGetViews(response: Response): Observable<ResultSetOfTrackingInfo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfTrackingInfo.fromJS(resultData200) : new ResultSetOfTrackingInfo();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfTrackingInfo>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    generateTracker(subscriptionId: string, documentId: string, request?: DocumentTrackingRequest | null): Observable<Tracker> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/documents/{documentId}/trackings";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGenerateTracker(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGenerateTracker(response_);
                } catch (e) {
                    return <Observable<Tracker>><any>Observable.throw(e);
                }
            } else
                return <Observable<Tracker>><any>Observable.throw(response_);
        });
    }

    protected processGenerateTracker(response: Response): Observable<Tracker> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Tracker.fromJS(resultData200) : new Tracker();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Tracker>(<any>null);
    }

    /**
     * @return Success
     */
    getDocumentType(subscriptionId: string, documentId: string): Observable<DocumentType> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/documents/{documentId}/type";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetDocumentType(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetDocumentType(response_);
                } catch (e) {
                    return <Observable<DocumentType>><any>Observable.throw(e);
                }
            } else
                return <Observable<DocumentType>><any>Observable.throw(response_);
        });
    }

    protected processGetDocumentType(response: Response): Observable<DocumentType> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentType.fromJS(resultData200) : new DocumentType();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DocumentType>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    changeDocumentType(subscriptionId: string, documentId: string, request?: ChangeDocumentTypeRequest | null): Observable<DocumentType> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/documents/{documentId}/type";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processChangeDocumentType(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processChangeDocumentType(response_);
                } catch (e) {
                    return <Observable<DocumentType>><any>Observable.throw(e);
                }
            } else
                return <Observable<DocumentType>><any>Observable.throw(response_);
        });
    }

    protected processChangeDocumentType(response: Response): Observable<DocumentType> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentType.fromJS(resultData200) : new DocumentType();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DocumentType>(<any>null);
    }

    /**
     * @page (optional) 
     * @size (optional) 
     * @sort (optional) 
     * @search (optional) 
     * @return Success
     */
    getDocumentTypes(subscriptionId: string, page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfDocumentTypeInfo> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/document-types?";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetDocumentTypes(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetDocumentTypes(response_);
                } catch (e) {
                    return <Observable<ResultSetOfDocumentTypeInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfDocumentTypeInfo>><any>Observable.throw(response_);
        });
    }

    protected processGetDocumentTypes(response: Response): Observable<ResultSetOfDocumentTypeInfo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfDocumentTypeInfo.fromJS(resultData200) : new ResultSetOfDocumentTypeInfo();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfDocumentTypeInfo>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    createDocumentType(subscriptionId: string, request?: CreateDocumentTypeRequest | null): Observable<DocumentType> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/document-types";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateDocumentType(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateDocumentType(response_);
                } catch (e) {
                    return <Observable<DocumentType>><any>Observable.throw(e);
                }
            } else
                return <Observable<DocumentType>><any>Observable.throw(response_);
        });
    }

    protected processCreateDocumentType(response: Response): Observable<DocumentType> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? DocumentType.fromJS(resultData201) : new DocumentType();
            return Observable.of(result201);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DocumentType>(<any>null);
    }

    /**
     * @return Success
     */
    getDocumentType2(subscriptionId: string, documentTypeId: string): Observable<DocumentType> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/document-types/{documentTypeId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (documentTypeId === undefined || documentTypeId === null)
            throw new Error("The parameter 'documentTypeId' must be defined.");
        url_ = url_.replace("{documentTypeId}", encodeURIComponent("" + documentTypeId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetDocumentType2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetDocumentType2(response_);
                } catch (e) {
                    return <Observable<DocumentType>><any>Observable.throw(e);
                }
            } else
                return <Observable<DocumentType>><any>Observable.throw(response_);
        });
    }

    protected processGetDocumentType2(response: Response): Observable<DocumentType> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentType.fromJS(resultData200) : new DocumentType();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DocumentType>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    updateDocumentType(subscriptionId: string, documentTypeId: string, request?: UpdateDocumentTypeRequest | null): Observable<DocumentType> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/document-types/{documentTypeId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (documentTypeId === undefined || documentTypeId === null)
            throw new Error("The parameter 'documentTypeId' must be defined.");
        url_ = url_.replace("{documentTypeId}", encodeURIComponent("" + documentTypeId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateDocumentType(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateDocumentType(response_);
                } catch (e) {
                    return <Observable<DocumentType>><any>Observable.throw(e);
                }
            } else
                return <Observable<DocumentType>><any>Observable.throw(response_);
        });
    }

    protected processUpdateDocumentType(response: Response): Observable<DocumentType> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentType.fromJS(resultData200) : new DocumentType();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DocumentType>(<any>null);
    }

    /**
     * @return Success
     */
    deleteDocumentType(subscriptionId: string, documentTypeId: string): Observable<void> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/document-types/{documentTypeId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (documentTypeId === undefined || documentTypeId === null)
            throw new Error("The parameter 'documentTypeId' must be defined.");
        url_ = url_.replace("{documentTypeId}", encodeURIComponent("" + documentTypeId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeleteDocumentType(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteDocumentType(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteDocumentType(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @page (optional) 
     * @size (optional) 
     * @sort (optional) 
     * @search (optional) 
     * @return Success
     */
    getPaymentOptions(subscriptionId: string, documentTypeId: string, page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfPaymentOptionInfo> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/document-types/{documentTypeId}/payment-options?";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (documentTypeId === undefined || documentTypeId === null)
            throw new Error("The parameter 'documentTypeId' must be defined.");
        url_ = url_.replace("{documentTypeId}", encodeURIComponent("" + documentTypeId)); 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetPaymentOptions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetPaymentOptions(response_);
                } catch (e) {
                    return <Observable<ResultSetOfPaymentOptionInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfPaymentOptionInfo>><any>Observable.throw(response_);
        });
    }

    protected processGetPaymentOptions(response: Response): Observable<ResultSetOfPaymentOptionInfo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfPaymentOptionInfo.fromJS(resultData200) : new ResultSetOfPaymentOptionInfo();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfPaymentOptionInfo>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    addPaymentOption(subscriptionId: string, documentTypeId: string, request?: PaymentOption | null): Observable<PaymentOption> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/document-types/{documentTypeId}/payment-options";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (documentTypeId === undefined || documentTypeId === null)
            throw new Error("The parameter 'documentTypeId' must be defined.");
        url_ = url_.replace("{documentTypeId}", encodeURIComponent("" + documentTypeId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processAddPaymentOption(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAddPaymentOption(response_);
                } catch (e) {
                    return <Observable<PaymentOption>><any>Observable.throw(e);
                }
            } else
                return <Observable<PaymentOption>><any>Observable.throw(response_);
        });
    }

    protected processAddPaymentOption(response: Response): Observable<PaymentOption> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PaymentOption.fromJS(resultData200) : new PaymentOption();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PaymentOption>(<any>null);
    }

    /**
     * @return Success
     */
    deletePaymentOption(subscriptionId: string, documentTypeId: string, paymentOptionId: string): Observable<void> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/document-types/{documentTypeId}/payment-options/{paymentOptionId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (documentTypeId === undefined || documentTypeId === null)
            throw new Error("The parameter 'documentTypeId' must be defined.");
        url_ = url_.replace("{documentTypeId}", encodeURIComponent("" + documentTypeId)); 
        if (paymentOptionId === undefined || paymentOptionId === null)
            throw new Error("The parameter 'paymentOptionId' must be defined.");
        url_ = url_.replace("{paymentOptionId}", encodeURIComponent("" + paymentOptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeletePaymentOption(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeletePaymentOption(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeletePaymentOption(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getDocumentTypeTemplate(subscriptionId: string, documentTypeId: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/document-types/{documentTypeId}/template";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (documentTypeId === undefined || documentTypeId === null)
            throw new Error("The parameter 'documentTypeId' must be defined.");
        url_ = url_.replace("{documentTypeId}", encodeURIComponent("" + documentTypeId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            responseType: ResponseContentType.Blob,
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetDocumentTypeTemplate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetDocumentTypeTemplate(response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse>><any>Observable.throw(response_);
        });
    }

    protected processGetDocumentTypeTemplate(response: Response): Observable<FileResponse> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>response.blob(), status: status, headers: _headers });
        } else if (status === 404) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>response.blob(), status: status, headers: _headers });
        } else if (status === 401) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>response.blob(), status: status, headers: _headers });
        } else if (status === 403) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>response.blob(), status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.blob()).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse>(<any>null);
    }

    /**
     * @file (optional) 
     * @return Success
     */
    updateDocumentTypeTemplate(subscriptionId: string, documentTypeId: string, file?: FileParameter | null): Observable<void> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/document-types/{documentTypeId}/template";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (documentTypeId === undefined || documentTypeId === null)
            throw new Error("The parameter 'documentTypeId' must be defined.");
        url_ = url_.replace("{documentTypeId}", encodeURIComponent("" + documentTypeId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateDocumentTypeTemplate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateDocumentTypeTemplate(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateDocumentTypeTemplate(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAvailableThemes(subscriptionId: string, recordType: RecordType): Observable<ResultSetOfLookupEntry> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/document-types/{recordType}/themes";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (recordType === undefined || recordType === null)
            throw new Error("The parameter 'recordType' must be defined.");
        url_ = url_.replace("{recordType}", encodeURIComponent("" + recordType)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAvailableThemes(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAvailableThemes(response_);
                } catch (e) {
                    return <Observable<ResultSetOfLookupEntry>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfLookupEntry>><any>Observable.throw(response_);
        });
    }

    protected processGetAvailableThemes(response: Response): Observable<ResultSetOfLookupEntry> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfLookupEntry.fromJS(resultData200) : new ResultSetOfLookupEntry();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfLookupEntry>(<any>null);
    }

    /**
     * @page (optional) 
     * @size (optional) 
     * @sort (optional) 
     * @search (optional) 
     * @return Success
     */
    getSubscriptionMembers(subscriptionId: string, page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfSubscriptionMemberInfo> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/members?";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetSubscriptionMembers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetSubscriptionMembers(response_);
                } catch (e) {
                    return <Observable<ResultSetOfSubscriptionMemberInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfSubscriptionMemberInfo>><any>Observable.throw(response_);
        });
    }

    protected processGetSubscriptionMembers(response: Response): Observable<ResultSetOfSubscriptionMemberInfo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfSubscriptionMemberInfo.fromJS(resultData200) : new ResultSetOfSubscriptionMemberInfo();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfSubscriptionMemberInfo>(<any>null);
    }

    /**
     * @filter_From (optional) 
     * @filter_To (optional) 
     * @page (optional) 
     * @size (optional) 
     * @sort (optional) 
     * @search (optional) 
     * @return Success
     */
    getSubscriptionMetrics(subscriptionId: string, filter_From?: Date | null, filter_To?: Date | null, page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfMetricsRecord> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/metrics?";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (filter_From !== undefined)
            url_ += "Filter.From=" + encodeURIComponent(filter_From ? "" + filter_From.toJSON() : "") + "&"; 
        if (filter_To !== undefined)
            url_ += "Filter.To=" + encodeURIComponent(filter_To ? "" + filter_To.toJSON() : "") + "&"; 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetSubscriptionMetrics(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetSubscriptionMetrics(response_);
                } catch (e) {
                    return <Observable<ResultSetOfMetricsRecord>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfMetricsRecord>><any>Observable.throw(response_);
        });
    }

    protected processGetSubscriptionMetrics(response: Response): Observable<ResultSetOfMetricsRecord> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfMetricsRecord.fromJS(resultData200) : new ResultSetOfMetricsRecord();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfMetricsRecord>(<any>null);
    }

    /**
     * @filter_Customers (optional) 
     * @filter_Suppliers (optional) 
     * @filter_Code (optional) 
     * @page (optional) 
     * @size (optional) 
     * @sort (optional) 
     * @search (optional) 
     * @return Success
     */
    getOrganisations(subscriptionId: string, filter_Customers?: boolean | null, filter_Suppliers?: boolean | null, filter_Code?: string | null, page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfOrganisationInfo> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/organisations?";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (filter_Customers !== undefined)
            url_ += "Filter.Customers=" + encodeURIComponent("" + filter_Customers) + "&"; 
        if (filter_Suppliers !== undefined)
            url_ += "Filter.Suppliers=" + encodeURIComponent("" + filter_Suppliers) + "&"; 
        if (filter_Code !== undefined)
            url_ += "Filter.Code=" + encodeURIComponent("" + filter_Code) + "&"; 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetOrganisations(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetOrganisations(response_);
                } catch (e) {
                    return <Observable<ResultSetOfOrganisationInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfOrganisationInfo>><any>Observable.throw(response_);
        });
    }

    protected processGetOrganisations(response: Response): Observable<ResultSetOfOrganisationInfo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfOrganisationInfo.fromJS(resultData200) : new ResultSetOfOrganisationInfo();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfOrganisationInfo>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    createOrganisation(subscriptionId: string, request?: Organisation | null): Observable<Organisation> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/organisations";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateOrganisation(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateOrganisation(response_);
                } catch (e) {
                    return <Observable<Organisation>><any>Observable.throw(e);
                }
            } else
                return <Observable<Organisation>><any>Observable.throw(response_);
        });
    }

    protected processCreateOrganisation(response: Response): Observable<Organisation> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Organisation.fromJS(resultData201) : new Organisation();
            return Observable.of(result201);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Organisation>(<any>null);
    }

    /**
     * @return Success
     */
    getOrganisation(subscriptionId: string, organisationId: string): Observable<Organisation> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/organisations/{organisationId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (organisationId === undefined || organisationId === null)
            throw new Error("The parameter 'organisationId' must be defined.");
        url_ = url_.replace("{organisationId}", encodeURIComponent("" + organisationId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetOrganisation(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetOrganisation(response_);
                } catch (e) {
                    return <Observable<Organisation>><any>Observable.throw(e);
                }
            } else
                return <Observable<Organisation>><any>Observable.throw(response_);
        });
    }

    protected processGetOrganisation(response: Response): Observable<Organisation> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Organisation.fromJS(resultData200) : new Organisation();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Organisation>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    updateOrganisation(subscriptionId: string, organisationId: string, request?: UpdateOrganisationRequest | null): Observable<Organisation> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/organisations/{organisationId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (organisationId === undefined || organisationId === null)
            throw new Error("The parameter 'organisationId' must be defined.");
        url_ = url_.replace("{organisationId}", encodeURIComponent("" + organisationId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateOrganisation(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateOrganisation(response_);
                } catch (e) {
                    return <Observable<Organisation>><any>Observable.throw(e);
                }
            } else
                return <Observable<Organisation>><any>Observable.throw(response_);
        });
    }

    protected processUpdateOrganisation(response: Response): Observable<Organisation> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Organisation.fromJS(resultData200) : new Organisation();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Organisation>(<any>null);
    }

    /**
     * @page (optional) 
     * @size (optional) 
     * @sort (optional) 
     * @search (optional) 
     * @return Success
     */
    getPaymentOptions2(subscriptionId: string, page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfPaymentOptionInfo> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/payment-options?";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetPaymentOptions2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetPaymentOptions2(response_);
                } catch (e) {
                    return <Observable<ResultSetOfPaymentOptionInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfPaymentOptionInfo>><any>Observable.throw(response_);
        });
    }

    protected processGetPaymentOptions2(response: Response): Observable<ResultSetOfPaymentOptionInfo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfPaymentOptionInfo.fromJS(resultData200) : new ResultSetOfPaymentOptionInfo();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfPaymentOptionInfo>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    createPaymentOption(subscriptionId: string, request?: PaymentOption | null): Observable<PaymentOption> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/payment-options";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreatePaymentOption(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreatePaymentOption(response_);
                } catch (e) {
                    return <Observable<PaymentOption>><any>Observable.throw(e);
                }
            } else
                return <Observable<PaymentOption>><any>Observable.throw(response_);
        });
    }

    protected processCreatePaymentOption(response: Response): Observable<PaymentOption> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? PaymentOption.fromJS(resultData201) : new PaymentOption();
            return Observable.of(result201);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PaymentOption>(<any>null);
    }

    /**
     * @return Success
     */
    getPaymentOption(subscriptionId: string, paymentOptionId: string): Observable<PaymentOption> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/payment-options/{paymentOptionId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (paymentOptionId === undefined || paymentOptionId === null)
            throw new Error("The parameter 'paymentOptionId' must be defined.");
        url_ = url_.replace("{paymentOptionId}", encodeURIComponent("" + paymentOptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetPaymentOption(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetPaymentOption(response_);
                } catch (e) {
                    return <Observable<PaymentOption>><any>Observable.throw(e);
                }
            } else
                return <Observable<PaymentOption>><any>Observable.throw(response_);
        });
    }

    protected processGetPaymentOption(response: Response): Observable<PaymentOption> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PaymentOption.fromJS(resultData200) : new PaymentOption();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PaymentOption>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    updatePaymentOption(subscriptionId: string, paymentOptionId: string, request?: PaymentOption | null): Observable<PaymentOption> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/payment-options/{paymentOptionId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (paymentOptionId === undefined || paymentOptionId === null)
            throw new Error("The parameter 'paymentOptionId' must be defined.");
        url_ = url_.replace("{paymentOptionId}", encodeURIComponent("" + paymentOptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdatePaymentOption(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdatePaymentOption(response_);
                } catch (e) {
                    return <Observable<PaymentOption>><any>Observable.throw(e);
                }
            } else
                return <Observable<PaymentOption>><any>Observable.throw(response_);
        });
    }

    protected processUpdatePaymentOption(response: Response): Observable<PaymentOption> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PaymentOption.fromJS(resultData200) : new PaymentOption();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PaymentOption>(<any>null);
    }

    /**
     * @page (optional) 
     * @size (optional) 
     * @sort (optional) 
     * @search (optional) 
     * @return Success
     */
    getPaymentOptionDocumentTypes(subscriptionId: string, paymentOptionId: string, page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfDocumentTypeInfo> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/payment-options/{paymentOptionId}/document-types?";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (paymentOptionId === undefined || paymentOptionId === null)
            throw new Error("The parameter 'paymentOptionId' must be defined.");
        url_ = url_.replace("{paymentOptionId}", encodeURIComponent("" + paymentOptionId)); 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetPaymentOptionDocumentTypes(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetPaymentOptionDocumentTypes(response_);
                } catch (e) {
                    return <Observable<ResultSetOfDocumentTypeInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfDocumentTypeInfo>><any>Observable.throw(response_);
        });
    }

    protected processGetPaymentOptionDocumentTypes(response: Response): Observable<ResultSetOfDocumentTypeInfo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfDocumentTypeInfo.fromJS(resultData200) : new ResultSetOfDocumentTypeInfo();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfDocumentTypeInfo>(<any>null);
    }

    /**
     * @filter_BatchId (optional) 
     * @filter_From (optional) 
     * @filter_To (optional) 
     * @page (optional) 
     * @size (optional) 
     * @sort (optional) 
     * @search (optional) 
     * @return Success
     */
    getTransactions(subscriptionId: string, paymentOptionId: string, filter_BatchId?: string | null, filter_From?: Date | null, filter_To?: Date | null, page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfTransactionInfo> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/payment-options/{paymentOptionId}/transactions?";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (paymentOptionId === undefined || paymentOptionId === null)
            throw new Error("The parameter 'paymentOptionId' must be defined.");
        url_ = url_.replace("{paymentOptionId}", encodeURIComponent("" + paymentOptionId)); 
        if (filter_BatchId !== undefined)
            url_ += "Filter.BatchId=" + encodeURIComponent("" + filter_BatchId) + "&"; 
        if (filter_From !== undefined)
            url_ += "Filter.From=" + encodeURIComponent(filter_From ? "" + filter_From.toJSON() : "") + "&"; 
        if (filter_To !== undefined)
            url_ += "Filter.To=" + encodeURIComponent(filter_To ? "" + filter_To.toJSON() : "") + "&"; 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetTransactions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetTransactions(response_);
                } catch (e) {
                    return <Observable<ResultSetOfTransactionInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfTransactionInfo>><any>Observable.throw(response_);
        });
    }

    protected processGetTransactions(response: Response): Observable<ResultSetOfTransactionInfo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfTransactionInfo.fromJS(resultData200) : new ResultSetOfTransactionInfo();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfTransactionInfo>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    createTransaction(subscriptionId: string, paymentOptionId: string, request?: Transaction | null): Observable<Transaction> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/payment-options/{paymentOptionId}/transactions";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (paymentOptionId === undefined || paymentOptionId === null)
            throw new Error("The parameter 'paymentOptionId' must be defined.");
        url_ = url_.replace("{paymentOptionId}", encodeURIComponent("" + paymentOptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateTransaction(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateTransaction(response_);
                } catch (e) {
                    return <Observable<Transaction>><any>Observable.throw(e);
                }
            } else
                return <Observable<Transaction>><any>Observable.throw(response_);
        });
    }

    protected processCreateTransaction(response: Response): Observable<Transaction> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Transaction.fromJS(resultData201) : new Transaction();
            return Observable.of(result201);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Transaction>(<any>null);
    }

    /**
     * @return Success
     */
    getTransaction(subscriptionId: string, paymentOptionId: string, transactionId: string): Observable<Transaction> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/payment-options/{paymentOptionId}/transactions/{transactionId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (paymentOptionId === undefined || paymentOptionId === null)
            throw new Error("The parameter 'paymentOptionId' must be defined.");
        url_ = url_.replace("{paymentOptionId}", encodeURIComponent("" + paymentOptionId)); 
        if (transactionId === undefined || transactionId === null)
            throw new Error("The parameter 'transactionId' must be defined.");
        url_ = url_.replace("{transactionId}", encodeURIComponent("" + transactionId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetTransaction(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetTransaction(response_);
                } catch (e) {
                    return <Observable<Transaction>><any>Observable.throw(e);
                }
            } else
                return <Observable<Transaction>><any>Observable.throw(response_);
        });
    }

    protected processGetTransaction(response: Response): Observable<Transaction> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Transaction.fromJS(resultData200) : new Transaction();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Transaction>(<any>null);
    }

    /**
     * @page (optional) 
     * @size (optional) 
     * @sort (optional) 
     * @search (optional) 
     * @return Success
     */
    getTransactionPayments(subscriptionId: string, paymentOptionId: string, transactionId: string, page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfPaymentInfo> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/payment-options/{paymentOptionId}/transactions/{transactionId}/payments?";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (paymentOptionId === undefined || paymentOptionId === null)
            throw new Error("The parameter 'paymentOptionId' must be defined.");
        url_ = url_.replace("{paymentOptionId}", encodeURIComponent("" + paymentOptionId)); 
        if (transactionId === undefined || transactionId === null)
            throw new Error("The parameter 'transactionId' must be defined.");
        url_ = url_.replace("{transactionId}", encodeURIComponent("" + transactionId)); 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetTransactionPayments(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetTransactionPayments(response_);
                } catch (e) {
                    return <Observable<ResultSetOfPaymentInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfPaymentInfo>><any>Observable.throw(response_);
        });
    }

    protected processGetTransactionPayments(response: Response): Observable<ResultSetOfPaymentInfo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfPaymentInfo.fromJS(resultData200) : new ResultSetOfPaymentInfo();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfPaymentInfo>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    createTransactionPayment(subscriptionId: string, paymentOptionId: string, transactionId: string, request?: Payment | null): Observable<Payment> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/payment-options/{paymentOptionId}/transactions/{transactionId}/payments";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (paymentOptionId === undefined || paymentOptionId === null)
            throw new Error("The parameter 'paymentOptionId' must be defined.");
        url_ = url_.replace("{paymentOptionId}", encodeURIComponent("" + paymentOptionId)); 
        if (transactionId === undefined || transactionId === null)
            throw new Error("The parameter 'transactionId' must be defined.");
        url_ = url_.replace("{transactionId}", encodeURIComponent("" + transactionId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateTransactionPayment(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateTransactionPayment(response_);
                } catch (e) {
                    return <Observable<Payment>><any>Observable.throw(e);
                }
            } else
                return <Observable<Payment>><any>Observable.throw(response_);
        });
    }

    protected processCreateTransactionPayment(response: Response): Observable<Payment> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Payment.fromJS(resultData200) : new Payment();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Payment>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    bulkCreateTransactions(subscriptionId: string, paymentOptionId: string, request?: BulkLoadTransactionsRequest | null): Observable<void> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/payment-options/{paymentOptionId}/transactions/bulk";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (paymentOptionId === undefined || paymentOptionId === null)
            throw new Error("The parameter 'paymentOptionId' must be defined.");
        url_ = url_.replace("{paymentOptionId}", encodeURIComponent("" + paymentOptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processBulkCreateTransactions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processBulkCreateTransactions(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processBulkCreateTransactions(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getSubscriptionPlan(subscriptionId: string): Observable<Plan> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/plan";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetSubscriptionPlan(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetSubscriptionPlan(response_);
                } catch (e) {
                    return <Observable<Plan>><any>Observable.throw(e);
                }
            } else
                return <Observable<Plan>><any>Observable.throw(response_);
        });
    }

    protected processGetSubscriptionPlan(response: Response): Observable<Plan> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Plan.fromJS(resultData200) : new Plan();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Plan>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    updateSubscriptionPlan(subscriptionId: string, request?: Plan | null): Observable<Plan> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/plan";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateSubscriptionPlan(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateSubscriptionPlan(response_);
                } catch (e) {
                    return <Observable<Plan>><any>Observable.throw(e);
                }
            } else
                return <Observable<Plan>><any>Observable.throw(response_);
        });
    }

    protected processUpdateSubscriptionPlan(response: Response): Observable<Plan> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Plan.fromJS(resultData200) : new Plan();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Plan>(<any>null);
    }

    /**
     * @page (optional) 
     * @size (optional) 
     * @sort (optional) 
     * @search (optional) 
     * @return Success
     */
    getProducts(subscriptionId: string, page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfProductInfo> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/products?";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetProducts(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetProducts(response_);
                } catch (e) {
                    return <Observable<ResultSetOfProductInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfProductInfo>><any>Observable.throw(response_);
        });
    }

    protected processGetProducts(response: Response): Observable<ResultSetOfProductInfo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfProductInfo.fromJS(resultData200) : new ResultSetOfProductInfo();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfProductInfo>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    createProduct(subscriptionId: string, request?: Product | null): Observable<Product> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/products";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateProduct(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateProduct(response_);
                } catch (e) {
                    return <Observable<Product>><any>Observable.throw(e);
                }
            } else
                return <Observable<Product>><any>Observable.throw(response_);
        });
    }

    protected processCreateProduct(response: Response): Observable<Product> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Product.fromJS(resultData201) : new Product();
            return Observable.of(result201);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Product>(<any>null);
    }

    /**
     * @return Success
     */
    getProduct(subscriptionId: string, productId: string): Observable<Product> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/products/{productId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetProduct(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetProduct(response_);
                } catch (e) {
                    return <Observable<Product>><any>Observable.throw(e);
                }
            } else
                return <Observable<Product>><any>Observable.throw(response_);
        });
    }

    protected processGetProduct(response: Response): Observable<Product> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Product.fromJS(resultData200) : new Product();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Product>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    updateProduct(subscriptionId: string, productId: string, request?: Product | null): Observable<Product> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/products/{productId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateProduct(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateProduct(response_);
                } catch (e) {
                    return <Observable<Product>><any>Observable.throw(e);
                }
            } else
                return <Observable<Product>><any>Observable.throw(response_);
        });
    }

    protected processUpdateProduct(response: Response): Observable<Product> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Product.fromJS(resultData200) : new Product();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Product>(<any>null);
    }

    /**
     * @return Success
     */
    deleteProduct(subscriptionId: string, productId: string): Observable<void> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/products/{productId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeleteProduct(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteProduct(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteProduct(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getSubscriptionStatus(subscriptionId: string): Observable<Subscription> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/status";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetSubscriptionStatus(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetSubscriptionStatus(response_);
                } catch (e) {
                    return <Observable<Subscription>><any>Observable.throw(e);
                }
            } else
                return <Observable<Subscription>><any>Observable.throw(response_);
        });
    }

    protected processGetSubscriptionStatus(response: Response): Observable<Subscription> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Subscription.fromJS(resultData200) : new Subscription();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Subscription>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    updateSubscriptionStatus(subscriptionId: string, request?: UpdateSubscriptionStatusRequest | null): Observable<Subscription> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/status";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateSubscriptionStatus(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateSubscriptionStatus(response_);
                } catch (e) {
                    return <Observable<Subscription>><any>Observable.throw(e);
                }
            } else
                return <Observable<Subscription>><any>Observable.throw(response_);
        });
    }

    protected processUpdateSubscriptionStatus(response: Response): Observable<Subscription> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Subscription.fromJS(resultData200) : new Subscription();
            return Observable.of(result200);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Subscription>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    updateSubscriptionTimeZone(subscriptionId: string, request?: UpdateSubscriptionTimeZoneRequest | null): Observable<void> {
        let url_ = this.baseUrl + "/subscriptions/{subscriptionId}/time-zone";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateSubscriptionTimeZone(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateSubscriptionTimeZone(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateSubscriptionTimeZone(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @filter_Code (optional) 
     * @filter_MemberId (optional) 
     * @page (optional) 
     * @size (optional) 
     * @sort (optional) 
     * @search (optional) 
     * @return Success
     */
    getSubscriptionsGlobal(filter_Code?: string | null, filter_MemberId?: string | null, page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfSubscriptionInfo> {
        let url_ = this.baseUrl + "/subscriptions/all?";
        if (filter_Code !== undefined)
            url_ += "Filter.Code=" + encodeURIComponent("" + filter_Code) + "&"; 
        if (filter_MemberId !== undefined)
            url_ += "Filter.MemberId=" + encodeURIComponent("" + filter_MemberId) + "&"; 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetSubscriptionsGlobal(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetSubscriptionsGlobal(response_);
                } catch (e) {
                    return <Observable<ResultSetOfSubscriptionInfo>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfSubscriptionInfo>><any>Observable.throw(response_);
        });
    }

    protected processGetSubscriptionsGlobal(response: Response): Observable<ResultSetOfSubscriptionInfo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfSubscriptionInfo.fromJS(resultData200) : new ResultSetOfSubscriptionInfo();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfSubscriptionInfo>(<any>null);
    }

    /**
     * @filter_From (optional) 
     * @filter_To (optional) 
     * @page (optional) 
     * @size (optional) 
     * @sort (optional) 
     * @search (optional) 
     * @return Success
     */
    getGlobalMetrics(filter_From?: Date | null, filter_To?: Date | null, page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfMetricsRecord> {
        let url_ = this.baseUrl + "/subscriptions/all/metrics?";
        if (filter_From !== undefined)
            url_ += "Filter.From=" + encodeURIComponent(filter_From ? "" + filter_From.toJSON() : "") + "&"; 
        if (filter_To !== undefined)
            url_ += "Filter.To=" + encodeURIComponent(filter_To ? "" + filter_To.toJSON() : "") + "&"; 
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetGlobalMetrics(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetGlobalMetrics(response_);
                } catch (e) {
                    return <Observable<ResultSetOfMetricsRecord>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfMetricsRecord>><any>Observable.throw(response_);
        });
    }

    protected processGetGlobalMetrics(response: Response): Observable<ResultSetOfMetricsRecord> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfMetricsRecord.fromJS(resultData200) : new ResultSetOfMetricsRecord();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfMetricsRecord>(<any>null);
    }

    /**
     * @page (optional) 
     * @size (optional) 
     * @sort (optional) 
     * @search (optional) 
     * @return Success
     */
    getTimeZones(page?: number | null, size?: number | null, sort?: string | null, search?: string | null): Observable<ResultSetOfTimeZone> {
        let url_ = this.baseUrl + "/timezones?";
        if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&"; 
        if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&"; 
        if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetTimeZones(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetTimeZones(response_);
                } catch (e) {
                    return <Observable<ResultSetOfTimeZone>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResultSetOfTimeZone>><any>Observable.throw(response_);
        });
    }

    protected processGetTimeZones(response: Response): Observable<ResultSetOfTimeZone> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResultSetOfTimeZone.fromJS(resultData200) : new ResultSetOfTimeZone();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ResultSetOfTimeZone>(<any>null);
    }

    /**
     * @return Success
     */
    getTimeZoneById(zoneId: string): Observable<TimeZone> {
        let url_ = this.baseUrl + "/timezones/{zoneId}";
        if (zoneId === undefined || zoneId === null)
            throw new Error("The parameter 'zoneId' must be defined.");
        url_ = url_.replace("{zoneId}", encodeURIComponent("" + zoneId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetTimeZoneById(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetTimeZoneById(response_);
                } catch (e) {
                    return <Observable<TimeZone>><any>Observable.throw(e);
                }
            } else
                return <Observable<TimeZone>><any>Observable.throw(response_);
        });
    }

    protected processGetTimeZoneById(response: Response): Observable<TimeZone> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TimeZone.fromJS(resultData200) : new TimeZone();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TimeZone>(<any>null);
    }
}

export class ResultSetOfLookupEntry {
    count?: number | undefined;
    items?: LookupEntry[] | undefined;

    init(data?: any) {
        if (data) {
            this.count = data["count"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LookupEntry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultSetOfLookupEntry {
        let result = new ResultSetOfLookupEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ResultSetOfLookupEntry();
        result.init(json);
        return result;
    }
}

export class LookupEntry {
    id?: string | undefined;
    description?: string | undefined;

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): LookupEntry {
        let result = new LookupEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new LookupEntry();
        result.init(json);
        return result;
    }
}

export class ResultSetOfCountryInfo {
    count?: number | undefined;
    items?: Country[] | undefined;

    init(data?: any) {
        if (data) {
            this.count = data["count"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Country.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultSetOfCountryInfo {
        let result = new ResultSetOfCountryInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ResultSetOfCountryInfo();
        result.init(json);
        return result;
    }
}

export class Country {
    readonly name?: string | undefined;
    readonly twoLetterCode?: string | undefined;
    readonly twoLetterLanguageCode?: string | undefined;
    readonly numericCode?: number | undefined;
    readonly locale?: string | undefined;

    init(data?: any) {
        if (data) {
            (<any>this).name = data["name"];
            (<any>this).twoLetterCode = data["twoLetterCode"];
            (<any>this).twoLetterLanguageCode = data["twoLetterLanguageCode"];
            (<any>this).numericCode = data["numericCode"];
            (<any>this).locale = data["locale"];
        }
    }

    static fromJS(data: any): Country {
        let result = new Country();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["twoLetterCode"] = this.twoLetterCode;
        data["twoLetterLanguageCode"] = this.twoLetterLanguageCode;
        data["numericCode"] = this.numericCode;
        data["locale"] = this.locale;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Country();
        result.init(json);
        return result;
    }
}

export class ResultSetOfCurrencyInfo {
    count?: number | undefined;
    items?: Currency[] | undefined;

    init(data?: any) {
        if (data) {
            this.count = data["count"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Currency.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultSetOfCurrencyInfo {
        let result = new ResultSetOfCurrencyInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ResultSetOfCurrencyInfo();
        result.init(json);
        return result;
    }
}

export class Currency {
    readonly name?: string | undefined;
    readonly nativeName?: string | undefined;
    readonly symbol?: string | undefined;
    readonly alignRight?: boolean | undefined;
    readonly isoSymbol?: string | undefined;
    readonly fraction?: Fraction | undefined;

    init(data?: any) {
        if (data) {
            (<any>this).name = data["name"];
            (<any>this).nativeName = data["nativeName"];
            (<any>this).symbol = data["symbol"];
            (<any>this).alignRight = data["alignRight"];
            (<any>this).isoSymbol = data["isoSymbol"];
            (<any>this).fraction = data["fraction"] ? Fraction.fromJS(data["fraction"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Currency {
        let result = new Currency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nativeName"] = this.nativeName;
        data["symbol"] = this.symbol;
        data["alignRight"] = this.alignRight;
        data["isoSymbol"] = this.isoSymbol;
        data["fraction"] = this.fraction ? this.fraction.toJSON() : <any>undefined;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Currency();
        result.init(json);
        return result;
    }
}

export class Fraction {
    readonly name?: string | undefined;
    readonly symbol?: string | undefined;
    readonly denominator?: number | undefined;

    init(data?: any) {
        if (data) {
            (<any>this).name = data["name"];
            (<any>this).symbol = data["symbol"];
            (<any>this).denominator = data["denominator"];
        }
    }

    static fromJS(data: any): Fraction {
        let result = new Fraction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["symbol"] = this.symbol;
        data["denominator"] = this.denominator;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Fraction();
        result.init(json);
        return result;
    }
}

export class ResultSetOfSubscriptionInfo {
    count?: number | undefined;
    items?: Subscription[] | undefined;

    init(data?: any) {
        if (data) {
            this.count = data["count"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Subscription.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultSetOfSubscriptionInfo {
        let result = new ResultSetOfSubscriptionInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ResultSetOfSubscriptionInfo();
        result.init(json);
        return result;
    }
}

export class Subscription {
    id?: string | undefined;
    code?: string | undefined;
    alias?: string | undefined;
    timeZone?: string | undefined;
    status?: SubscriptionStatus | undefined;
    company?: Organisation | undefined;
    contact?: Contact | undefined;
    plan?: Plan | undefined;
    notes?: string | undefined;
    customData?: any | undefined;

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.code = data["code"];
            this.alias = data["alias"];
            this.timeZone = data["timeZone"];
            this.status = data["status"];
            this.company = data["company"] ? Organisation.fromJS(data["company"]) : <any>undefined;
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : <any>undefined;
            this.plan = data["plan"] ? Plan.fromJS(data["plan"]) : <any>undefined;
            this.notes = data["notes"];
            if (data["customData"]) {
                this.customData = {};
                for (let key in data["customData"]) {
                    if (data["customData"].hasOwnProperty(key))
                        this.customData[key] = data["customData"][key];
                }
            }
        }
    }

    static fromJS(data: any): Subscription {
        let result = new Subscription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["alias"] = this.alias;
        data["timeZone"] = this.timeZone;
        data["status"] = this.status;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["plan"] = this.plan ? this.plan.toJSON() : <any>undefined;
        data["notes"] = this.notes;
        if (this.customData) {
            data["customData"] = {};
            for (let key in this.customData) {
                if (this.customData.hasOwnProperty(key))
                    data["customData"][key] = this.customData[key];
            }
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Subscription();
        result.init(json);
        return result;
    }
}

export class Organisation {
    id?: string | undefined;
    code?: string | undefined;
    logoPath?: string | undefined;
    name: string;
    legalName?: string | undefined;
    lineOfBusiness?: string | undefined;
    taxCode?: string | undefined;
    taxOffice?: string | undefined;
    currencyCode?: string | undefined;
    address: Address = new Address();
    email?: string | undefined;
    website?: string | undefined;
    notes?: string | undefined;
    customData?: any | undefined;
    paymentMethods?: PaymentMethod[] | undefined;

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.code = data["code"];
            this.logoPath = data["logoPath"];
            this.name = data["name"];
            this.legalName = data["legalName"];
            this.lineOfBusiness = data["lineOfBusiness"];
            this.taxCode = data["taxCode"];
            this.taxOffice = data["taxOffice"];
            this.currencyCode = data["currencyCode"];
            this.address = data["address"] ? Address.fromJS(data["address"]) : new Address();
            this.email = data["email"];
            this.website = data["website"];
            this.notes = data["notes"];
            if (data["customData"]) {
                this.customData = {};
                for (let key in data["customData"]) {
                    if (data["customData"].hasOwnProperty(key))
                        this.customData[key] = data["customData"][key];
                }
            }
            if (data["paymentMethods"] && data["paymentMethods"].constructor === Array) {
                this.paymentMethods = [];
                for (let item of data["paymentMethods"])
                    this.paymentMethods.push(PaymentMethod.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Organisation {
        let result = new Organisation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["logoPath"] = this.logoPath;
        data["name"] = this.name;
        data["legalName"] = this.legalName;
        data["lineOfBusiness"] = this.lineOfBusiness;
        data["taxCode"] = this.taxCode;
        data["taxOffice"] = this.taxOffice;
        data["currencyCode"] = this.currencyCode;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["email"] = this.email;
        data["website"] = this.website;
        data["notes"] = this.notes;
        if (this.customData) {
            data["customData"] = {};
            for (let key in this.customData) {
                if (this.customData.hasOwnProperty(key))
                    data["customData"][key] = this.customData[key];
            }
        }
        if (this.paymentMethods && this.paymentMethods.constructor === Array) {
            data["paymentMethods"] = [];
            for (let item of this.paymentMethods)
                data["paymentMethods"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Organisation();
        result.init(json);
        return result;
    }
}

export class Contact {
    id?: string | undefined;
    code?: string | undefined;
    displayName?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    address?: Address | undefined;
    phone1?: string | undefined;
    phone2?: string | undefined;
    skype?: string | undefined;
    notes?: string | undefined;
    customData?: any | undefined;

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.code = data["code"];
            this.displayName = data["displayName"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.address = data["address"] ? Address.fromJS(data["address"]) : <any>undefined;
            this.phone1 = data["phone1"];
            this.phone2 = data["phone2"];
            this.skype = data["skype"];
            this.notes = data["notes"];
            if (data["customData"]) {
                this.customData = {};
                for (let key in data["customData"]) {
                    if (data["customData"].hasOwnProperty(key))
                        this.customData[key] = data["customData"][key];
                }
            }
        }
    }

    static fromJS(data: any): Contact {
        let result = new Contact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["phone1"] = this.phone1;
        data["phone2"] = this.phone2;
        data["skype"] = this.skype;
        data["notes"] = this.notes;
        if (this.customData) {
            data["customData"] = {};
            for (let key in this.customData) {
                if (this.customData.hasOwnProperty(key))
                    data["customData"][key] = this.customData[key];
            }
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Contact();
        result.init(json);
        return result;
    }
}

export class Plan {
    name?: string | undefined;
    description?: string | undefined;
    richText?: string | undefined;
    uiHint?: UiHint | undefined;
    services?: Service[] | undefined;
    limits?: LimitPolicy[] | undefined;

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
            this.richText = data["richText"];
            this.uiHint = data["uiHint"] ? UiHint.fromJS(data["uiHint"]) : <any>undefined;
            if (data["services"] && data["services"].constructor === Array) {
                this.services = [];
                for (let item of data["services"])
                    this.services.push(Service.fromJS(item));
            }
            if (data["limits"] && data["limits"].constructor === Array) {
                this.limits = [];
                for (let item of data["limits"])
                    this.limits.push(LimitPolicy.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Plan {
        let result = new Plan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["richText"] = this.richText;
        data["uiHint"] = this.uiHint ? this.uiHint.toJSON() : <any>undefined;
        if (this.services && this.services.constructor === Array) {
            data["services"] = [];
            for (let item of this.services)
                data["services"].push(item.toJSON());
        }
        if (this.limits && this.limits.constructor === Array) {
            data["limits"] = [];
            for (let item of this.limits)
                data["limits"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Plan();
        result.init(json);
        return result;
    }
}

export class Address {
    name?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    city?: string | undefined;
    zipCode?: string | undefined;
    countryCode: string;
    readonly country?: string | undefined;
    phone1?: string | undefined;
    phone2?: string | undefined;
    notes?: string | undefined;

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.line1 = data["line1"];
            this.line2 = data["line2"];
            this.city = data["city"];
            this.zipCode = data["zipCode"];
            this.countryCode = data["countryCode"];
            (<any>this).country = data["country"];
            this.phone1 = data["phone1"];
            this.phone2 = data["phone2"];
            this.notes = data["notes"];
        }
    }

    static fromJS(data: any): Address {
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["city"] = this.city;
        data["zipCode"] = this.zipCode;
        data["countryCode"] = this.countryCode;
        data["country"] = this.country;
        data["phone1"] = this.phone1;
        data["phone2"] = this.phone2;
        data["notes"] = this.notes;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Address();
        result.init(json);
        return result;
    }
}

export class PaymentMethod {
    code?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    type?: PaymentMethodType | undefined;

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.description = data["description"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): PaymentMethod {
        let result = new PaymentMethod();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["type"] = this.type;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PaymentMethod();
        result.init(json);
        return result;
    }
}

export class UiHint {
    theme?: string | undefined;
    accent?: AccentColor | undefined;
    icon?: string | undefined;
    stuff?: any | undefined;

    init(data?: any) {
        if (data) {
            this.theme = data["theme"];
            this.accent = data["accent"] ? AccentColor.fromJS(data["accent"]) : <any>undefined;
            this.icon = data["icon"];
            if (data["stuff"]) {
                this.stuff = {};
                for (let key in data["stuff"]) {
                    if (data["stuff"].hasOwnProperty(key))
                        this.stuff[key] = data["stuff"][key];
                }
            }
        }
    }

    static fromJS(data: any): UiHint {
        let result = new UiHint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        data["accent"] = this.accent ? this.accent.toJSON() : <any>undefined;
        data["icon"] = this.icon;
        if (this.stuff) {
            data["stuff"] = {};
            for (let key in this.stuff) {
                if (this.stuff.hasOwnProperty(key))
                    data["stuff"][key] = this.stuff[key];
            }
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UiHint();
        result.init(json);
        return result;
    }
}

export class Service {
    name: string;
    description?: string | undefined;
    type: string;
    enabled?: boolean | undefined;
    uiHint?: UiHint | undefined;
    settings?: any | undefined;

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
            this.type = data["type"];
            this.enabled = data["enabled"];
            this.uiHint = data["uiHint"] ? UiHint.fromJS(data["uiHint"]) : <any>undefined;
            if (data["settings"]) {
                this.settings = {};
                for (let key in data["settings"]) {
                    if (data["settings"].hasOwnProperty(key))
                        this.settings[key] = data["settings"][key];
                }
            }
        }
    }

    static fromJS(data: any): Service {
        let result = new Service();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["type"] = this.type;
        data["enabled"] = this.enabled;
        data["uiHint"] = this.uiHint ? this.uiHint.toJSON() : <any>undefined;
        if (this.settings) {
            data["settings"] = {};
            for (let key in this.settings) {
                if (this.settings.hasOwnProperty(key))
                    data["settings"][key] = this.settings[key];
            }
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Service();
        result.init(json);
        return result;
    }
}

export class LimitPolicy {
    name?: string | undefined;
    rules?: LimitRule[] | undefined;

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["rules"] && data["rules"].constructor === Array) {
                this.rules = [];
                for (let item of data["rules"])
                    this.rules.push(LimitRule.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LimitPolicy {
        let result = new LimitPolicy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.rules && this.rules.constructor === Array) {
            data["rules"] = [];
            for (let item of this.rules)
                data["rules"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new LimitPolicy();
        result.init(json);
        return result;
    }
}

export class AccentColor {
    type?: AccentColorType | undefined;
    foreground?: string | undefined;
    background?: string | undefined;

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.foreground = data["foreground"];
            this.background = data["background"];
        }
    }

    static fromJS(data: any): AccentColor {
        let result = new AccentColor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["foreground"] = this.foreground;
        data["background"] = this.background;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new AccentColor();
        result.init(json);
        return result;
    }
}

export class LimitRule {
    endpoint?: string | undefined;
    period?: string | undefined;
    periodTimespan?: string | undefined;
    limit?: number | undefined;

    init(data?: any) {
        if (data) {
            this.endpoint = data["endpoint"];
            this.period = data["period"];
            this.periodTimespan = data["periodTimespan"];
            this.limit = data["limit"];
        }
    }

    static fromJS(data: any): LimitRule {
        let result = new LimitRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["endpoint"] = this.endpoint;
        data["period"] = this.period;
        data["periodTimespan"] = this.periodTimespan;
        data["limit"] = this.limit;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new LimitRule();
        result.init(json);
        return result;
    }
}

export class CreateSubscriptionRequest {
    type?: CreateSubscriptionRequestType | undefined;
    code?: string | undefined;
    alias?: string | undefined;
    timeZone?: string | undefined;
    company: Organisation = new Organisation();
    contact: Contact = new Contact();
    notes?: string | undefined;
    customData?: any | undefined;

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.code = data["code"];
            this.alias = data["alias"];
            this.timeZone = data["timeZone"];
            this.company = data["company"] ? Organisation.fromJS(data["company"]) : new Organisation();
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : new Contact();
            this.notes = data["notes"];
            if (data["customData"]) {
                this.customData = {};
                for (let key in data["customData"]) {
                    if (data["customData"].hasOwnProperty(key))
                        this.customData[key] = data["customData"][key];
                }
            }
        }
    }

    static fromJS(data: any): CreateSubscriptionRequest {
        let result = new CreateSubscriptionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["code"] = this.code;
        data["alias"] = this.alias;
        data["timeZone"] = this.timeZone;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["notes"] = this.notes;
        if (this.customData) {
            data["customData"] = {};
            for (let key in this.customData) {
                if (this.customData.hasOwnProperty(key))
                    data["customData"][key] = this.customData[key];
            }
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CreateSubscriptionRequest();
        result.init(json);
        return result;
    }
}

export class UpdateSubscriptionCompanyRequest {
    code?: string | undefined;
    logoPath?: string | undefined;
    name: string;
    legalName?: string | undefined;
    lineOfBusiness?: string | undefined;
    taxCode?: string | undefined;
    taxOffice?: string | undefined;
    currencyCode?: string | undefined;
    address: Address = new Address();
    email: string;
    website?: string | undefined;
    notes?: string | undefined;
    customData?: any | undefined;
    paymentMethods?: PaymentMethod[] | undefined;

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.logoPath = data["logoPath"];
            this.name = data["name"];
            this.legalName = data["legalName"];
            this.lineOfBusiness = data["lineOfBusiness"];
            this.taxCode = data["taxCode"];
            this.taxOffice = data["taxOffice"];
            this.currencyCode = data["currencyCode"];
            this.address = data["address"] ? Address.fromJS(data["address"]) : new Address();
            this.email = data["email"];
            this.website = data["website"];
            this.notes = data["notes"];
            if (data["customData"]) {
                this.customData = {};
                for (let key in data["customData"]) {
                    if (data["customData"].hasOwnProperty(key))
                        this.customData[key] = data["customData"][key];
                }
            }
            if (data["paymentMethods"] && data["paymentMethods"].constructor === Array) {
                this.paymentMethods = [];
                for (let item of data["paymentMethods"])
                    this.paymentMethods.push(PaymentMethod.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateSubscriptionCompanyRequest {
        let result = new UpdateSubscriptionCompanyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["logoPath"] = this.logoPath;
        data["name"] = this.name;
        data["legalName"] = this.legalName;
        data["lineOfBusiness"] = this.lineOfBusiness;
        data["taxCode"] = this.taxCode;
        data["taxOffice"] = this.taxOffice;
        data["currencyCode"] = this.currencyCode;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["email"] = this.email;
        data["website"] = this.website;
        data["notes"] = this.notes;
        if (this.customData) {
            data["customData"] = {};
            for (let key in this.customData) {
                if (this.customData.hasOwnProperty(key))
                    data["customData"][key] = this.customData[key];
            }
        }
        if (this.paymentMethods && this.paymentMethods.constructor === Array) {
            data["paymentMethods"] = [];
            for (let item of this.paymentMethods)
                data["paymentMethods"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UpdateSubscriptionCompanyRequest();
        result.init(json);
        return result;
    }
}

export class Link {
    name?: string | undefined;
    uri?: string | undefined;

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.uri = data["uri"];
        }
    }

    static fromJS(data: any): Link {
        let result = new Link();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["uri"] = this.uri;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Link();
        result.init(json);
        return result;
    }
}

export class UpdateContactRequest {
    displayName?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    address?: Address | undefined;
    phone1?: string | undefined;
    phone2?: string | undefined;
    skype?: string | undefined;
    notes?: string | undefined;

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.address = data["address"] ? Address.fromJS(data["address"]) : <any>undefined;
            this.phone1 = data["phone1"];
            this.phone2 = data["phone2"];
            this.skype = data["skype"];
            this.notes = data["notes"];
        }
    }

    static fromJS(data: any): UpdateContactRequest {
        let result = new UpdateContactRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["phone1"] = this.phone1;
        data["phone2"] = this.phone2;
        data["skype"] = this.skype;
        data["notes"] = this.notes;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UpdateContactRequest();
        result.init(json);
        return result;
    }
}

export class ResultSetOfContactInfo {
    count?: number | undefined;
    items?: Contact[] | undefined;

    init(data?: any) {
        if (data) {
            this.count = data["count"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Contact.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultSetOfContactInfo {
        let result = new ResultSetOfContactInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ResultSetOfContactInfo();
        result.init(json);
        return result;
    }
}

export class ResultSetOfOrganisationInfo {
    count?: number | undefined;
    items?: Organisation[] | undefined;

    init(data?: any) {
        if (data) {
            this.count = data["count"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Organisation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultSetOfOrganisationInfo {
        let result = new ResultSetOfOrganisationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ResultSetOfOrganisationInfo();
        result.init(json);
        return result;
    }
}

export class ResultSetOfDocumentInfo {
    count?: number | undefined;
    items?: Document[] | undefined;

    init(data?: any) {
        if (data) {
            this.count = data["count"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Document.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultSetOfDocumentInfo {
        let result = new ResultSetOfDocumentInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ResultSetOfDocumentInfo();
        result.init(json);
        return result;
    }
}

export class Document {
    id?: string | undefined;
    typeId?: string | undefined;
    number?: number | undefined;
    numberPrintable?: string | undefined;
    date?: Date | undefined;
    dueDate?: Date | undefined;
    status?: DocumentStatus | undefined;
    currencyCode?: string | undefined;
    currencyRate?: number | undefined;
    recipient?: Recipient | undefined;
    paymentCode?: string | undefined;
    lines?: DocumentLine[] | undefined;
    notes?: string | undefined;
    publicNotes?: string | undefined;
    tags?: string | undefined;
    readonly permaLink?: string | undefined;
    subTotal?: number | undefined;
    totalSalesTax?: number | undefined;
    totalTax?: number | undefined;
    total?: number | undefined;
    totalPayable?: number | undefined;

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.typeId = data["typeId"];
            this.number = data["number"];
            this.numberPrintable = data["numberPrintable"];
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>undefined;
            this.dueDate = data["dueDate"] ? new Date(data["dueDate"].toString()) : <any>undefined;
            this.status = data["status"];
            this.currencyCode = data["currencyCode"];
            this.currencyRate = data["currencyRate"];
            this.recipient = data["recipient"] ? Recipient.fromJS(data["recipient"]) : <any>undefined;
            this.paymentCode = data["paymentCode"];
            if (data["lines"] && data["lines"].constructor === Array) {
                this.lines = [];
                for (let item of data["lines"])
                    this.lines.push(DocumentLine.fromJS(item));
            }
            this.notes = data["notes"];
            this.publicNotes = data["publicNotes"];
            this.tags = data["tags"];
            (<any>this).permaLink = data["permaLink"];
            this.subTotal = data["subTotal"];
            this.totalSalesTax = data["totalSalesTax"];
            this.totalTax = data["totalTax"];
            this.total = data["total"];
            this.totalPayable = data["totalPayable"];
        }
    }

    static fromJS(data: any): Document {
        let result = new Document();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeId"] = this.typeId;
        data["number"] = this.number;
        data["numberPrintable"] = this.numberPrintable;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["currencyCode"] = this.currencyCode;
        data["currencyRate"] = this.currencyRate;
        data["recipient"] = this.recipient ? this.recipient.toJSON() : <any>undefined;
        data["paymentCode"] = this.paymentCode;
        if (this.lines && this.lines.constructor === Array) {
            data["lines"] = [];
            for (let item of this.lines)
                data["lines"].push(item.toJSON());
        }
        data["notes"] = this.notes;
        data["publicNotes"] = this.publicNotes;
        data["tags"] = this.tags;
        data["permaLink"] = this.permaLink;
        data["subTotal"] = this.subTotal;
        data["totalSalesTax"] = this.totalSalesTax;
        data["totalTax"] = this.totalTax;
        data["total"] = this.total;
        data["totalPayable"] = this.totalPayable;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Document();
        result.init(json);
        return result;
    }
}

export class Recipient {
    organisation?: Organisation | undefined;
    contact?: Contact | undefined;

    init(data?: any) {
        if (data) {
            this.organisation = data["organisation"] ? Organisation.fromJS(data["organisation"]) : <any>undefined;
            this.contact = data["contact"] ? Contact.fromJS(data["contact"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Recipient {
        let result = new Recipient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organisation"] = this.organisation ? this.organisation.toJSON() : <any>undefined;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Recipient();
        result.init(json);
        return result;
    }
}

export class DocumentLine {
    id?: string | undefined;
    product?: Product | undefined;
    description?: string | undefined;
    quantity?: number | undefined;
    unitAmount?: number | undefined;
    discountRate?: number | undefined;
    subTotal?: number | undefined;
    totalTax?: number | undefined;
    totalSalesTax?: number | undefined;
    total?: number | undefined;
    taxes?: Tax[] | undefined;
    readonly taxesDescription?: string | undefined;
    notes?: string | undefined;
    tags?: string | undefined;

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.product = data["product"] ? Product.fromJS(data["product"]) : <any>undefined;
            this.description = data["description"];
            this.quantity = data["quantity"];
            this.unitAmount = data["unitAmount"];
            this.discountRate = data["discountRate"];
            this.subTotal = data["subTotal"];
            this.totalTax = data["totalTax"];
            this.totalSalesTax = data["totalSalesTax"];
            this.total = data["total"];
            if (data["taxes"] && data["taxes"].constructor === Array) {
                this.taxes = [];
                for (let item of data["taxes"])
                    this.taxes.push(Tax.fromJS(item));
            }
            (<any>this).taxesDescription = data["taxesDescription"];
            this.notes = data["notes"];
            this.tags = data["tags"];
        }
    }

    static fromJS(data: any): DocumentLine {
        let result = new DocumentLine();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["quantity"] = this.quantity;
        data["unitAmount"] = this.unitAmount;
        data["discountRate"] = this.discountRate;
        data["subTotal"] = this.subTotal;
        data["totalTax"] = this.totalTax;
        data["totalSalesTax"] = this.totalSalesTax;
        data["total"] = this.total;
        if (this.taxes && this.taxes.constructor === Array) {
            data["taxes"] = [];
            for (let item of this.taxes)
                data["taxes"].push(item.toJSON());
        }
        data["taxesDescription"] = this.taxesDescription;
        data["notes"] = this.notes;
        data["tags"] = this.tags;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new DocumentLine();
        result.init(json);
        return result;
    }
}

export class Product {
    id?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    amount?: number | undefined;
    taxes?: Tax[] | undefined;
    notes?: string | undefined;
    publicNotes?: string | undefined;
    tags?: string | undefined;

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.code = data["code"];
            this.name = data["name"];
            this.amount = data["amount"];
            if (data["taxes"] && data["taxes"].constructor === Array) {
                this.taxes = [];
                for (let item of data["taxes"])
                    this.taxes.push(Tax.fromJS(item));
            }
            this.notes = data["notes"];
            this.publicNotes = data["publicNotes"];
            this.tags = data["tags"];
        }
    }

    static fromJS(data: any): Product {
        let result = new Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["amount"] = this.amount;
        if (this.taxes && this.taxes.constructor === Array) {
            data["taxes"] = [];
            for (let item of this.taxes)
                data["taxes"].push(item.toJSON());
        }
        data["notes"] = this.notes;
        data["publicNotes"] = this.publicNotes;
        data["tags"] = this.tags;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Product();
        result.init(json);
        return result;
    }
}

export class Tax {
    type?: TaxType | undefined;
    code?: string | undefined;
    name?: string | undefined;
    rate?: number | undefined;
    inclusive?: boolean | undefined;
    isSalesTax?: boolean | undefined;
    amount?: number | undefined;

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.code = data["code"];
            this.name = data["name"];
            this.rate = data["rate"];
            this.inclusive = data["inclusive"];
            this.isSalesTax = data["isSalesTax"];
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): Tax {
        let result = new Tax();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["code"] = this.code;
        data["name"] = this.name;
        data["rate"] = this.rate;
        data["inclusive"] = this.inclusive;
        data["isSalesTax"] = this.isSalesTax;
        data["amount"] = this.amount;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Tax();
        result.init(json);
        return result;
    }
}

export class CreateDocumentRequest {
    typeId?: string | undefined;
    number?: number | undefined;
    date?: Date | undefined;
    dueDate?: Date | undefined;
    status?: CreateDocumentRequestStatus | undefined;
    currencyCode?: string | undefined;
    currencyRate?: number | undefined;
    recipient: Recipient = new Recipient();
    paymentCode?: string | undefined;
    lines: DocumentLine[] = [];
    serverCalculations?: boolean | undefined;
    notes?: string | undefined;
    publicNotes?: string | undefined;
    tags?: string | undefined;
    subTotal?: number | undefined;
    totalSalesTax?: number | undefined;
    totalTax?: number | undefined;
    total?: number | undefined;
    totalPayable?: number | undefined;

    init(data?: any) {
        if (data) {
            this.typeId = data["typeId"];
            this.number = data["number"];
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>undefined;
            this.dueDate = data["dueDate"] ? new Date(data["dueDate"].toString()) : <any>undefined;
            this.status = data["status"];
            this.currencyCode = data["currencyCode"];
            this.currencyRate = data["currencyRate"];
            this.recipient = data["recipient"] ? Recipient.fromJS(data["recipient"]) : new Recipient();
            this.paymentCode = data["paymentCode"];
            if (data["lines"] && data["lines"].constructor === Array) {
                this.lines = [];
                for (let item of data["lines"])
                    this.lines.push(DocumentLine.fromJS(item));
            }
            this.serverCalculations = data["serverCalculations"];
            this.notes = data["notes"];
            this.publicNotes = data["publicNotes"];
            this.tags = data["tags"];
            this.subTotal = data["subTotal"];
            this.totalSalesTax = data["totalSalesTax"];
            this.totalTax = data["totalTax"];
            this.total = data["total"];
            this.totalPayable = data["totalPayable"];
        }
    }

    static fromJS(data: any): CreateDocumentRequest {
        let result = new CreateDocumentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["number"] = this.number;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["currencyCode"] = this.currencyCode;
        data["currencyRate"] = this.currencyRate;
        data["recipient"] = this.recipient ? this.recipient.toJSON() : <any>undefined;
        data["paymentCode"] = this.paymentCode;
        if (this.lines && this.lines.constructor === Array) {
            data["lines"] = [];
            for (let item of this.lines)
                data["lines"].push(item.toJSON());
        }
        data["serverCalculations"] = this.serverCalculations;
        data["notes"] = this.notes;
        data["publicNotes"] = this.publicNotes;
        data["tags"] = this.tags;
        data["subTotal"] = this.subTotal;
        data["totalSalesTax"] = this.totalSalesTax;
        data["totalTax"] = this.totalTax;
        data["total"] = this.total;
        data["totalPayable"] = this.totalPayable;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CreateDocumentRequest();
        result.init(json);
        return result;
    }
}

export class UpdateDocumentRequest {
    number?: number | undefined;
    date?: Date | undefined;
    dueDate?: Date | undefined;
    currencyCode?: string | undefined;
    currencyRate?: number | undefined;
    recipient?: Recipient | undefined;
    paymentCode?: string | undefined;
    lines: DocumentLine[] = [];
    serverCalculations?: boolean | undefined;
    notes?: string | undefined;
    publicNotes?: string | undefined;
    tags?: string | undefined;
    subTotal?: number | undefined;
    totalSalesTax?: number | undefined;
    totalTax?: number | undefined;
    total?: number | undefined;
    totalPayable?: number | undefined;

    init(data?: any) {
        if (data) {
            this.number = data["number"];
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>undefined;
            this.dueDate = data["dueDate"] ? new Date(data["dueDate"].toString()) : <any>undefined;
            this.currencyCode = data["currencyCode"];
            this.currencyRate = data["currencyRate"];
            this.recipient = data["recipient"] ? Recipient.fromJS(data["recipient"]) : <any>undefined;
            this.paymentCode = data["paymentCode"];
            if (data["lines"] && data["lines"].constructor === Array) {
                this.lines = [];
                for (let item of data["lines"])
                    this.lines.push(DocumentLine.fromJS(item));
            }
            this.serverCalculations = data["serverCalculations"];
            this.notes = data["notes"];
            this.publicNotes = data["publicNotes"];
            this.tags = data["tags"];
            this.subTotal = data["subTotal"];
            this.totalSalesTax = data["totalSalesTax"];
            this.totalTax = data["totalTax"];
            this.total = data["total"];
            this.totalPayable = data["totalPayable"];
        }
    }

    static fromJS(data: any): UpdateDocumentRequest {
        let result = new UpdateDocumentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["currencyCode"] = this.currencyCode;
        data["currencyRate"] = this.currencyRate;
        data["recipient"] = this.recipient ? this.recipient.toJSON() : <any>undefined;
        data["paymentCode"] = this.paymentCode;
        if (this.lines && this.lines.constructor === Array) {
            data["lines"] = [];
            for (let item of this.lines)
                data["lines"].push(item.toJSON());
        }
        data["serverCalculations"] = this.serverCalculations;
        data["notes"] = this.notes;
        data["publicNotes"] = this.publicNotes;
        data["tags"] = this.tags;
        data["subTotal"] = this.subTotal;
        data["totalSalesTax"] = this.totalSalesTax;
        data["totalTax"] = this.totalTax;
        data["total"] = this.total;
        data["totalPayable"] = this.totalPayable;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UpdateDocumentRequest();
        result.init(json);
        return result;
    }
}

export class Payment {
    id?: string | undefined;
    document?: Document | undefined;
    transaction?: Transaction | undefined;
    approval?: PaymentApproval | undefined;
    value?: Money | undefined;
    comments?: string | undefined;

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.document = data["document"] ? Document.fromJS(data["document"]) : <any>undefined;
            this.transaction = data["transaction"] ? Transaction.fromJS(data["transaction"]) : <any>undefined;
            this.approval = data["approval"];
            this.value = data["value"] ? Money.fromJS(data["value"]) : <any>undefined;
            this.comments = data["comments"];
        }
    }

    static fromJS(data: any): Payment {
        let result = new Payment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["document"] = this.document ? this.document.toJSON() : <any>undefined;
        data["transaction"] = this.transaction ? this.transaction.toJSON() : <any>undefined;
        data["approval"] = this.approval;
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        data["comments"] = this.comments;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Payment();
        result.init(json);
        return result;
    }
}

export class Transaction {
    id?: string | undefined;
    uniqueId: string;
    type: TransactionType;
    completed: Date;
    number?: string | undefined;
    description?: string | undefined;
    value: Money = new Money();
    balance?: Money | undefined;
    batchId?: string | undefined;
    subscriptionId?: string | undefined;

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.uniqueId = data["uniqueId"];
            this.type = data["type"];
            this.completed = data["completed"] ? new Date(data["completed"].toString()) : <any>undefined;
            this.number = data["number"];
            this.description = data["description"];
            this.value = data["value"] ? Money.fromJS(data["value"]) : new Money();
            this.balance = data["balance"] ? Money.fromJS(data["balance"]) : <any>undefined;
            this.batchId = data["batchId"];
            this.subscriptionId = data["subscriptionId"];
        }
    }

    static fromJS(data: any): Transaction {
        let result = new Transaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["uniqueId"] = this.uniqueId;
        data["type"] = this.type;
        data["completed"] = this.completed ? this.completed.toISOString() : <any>undefined;
        data["number"] = this.number;
        data["description"] = this.description;
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        data["balance"] = this.balance ? this.balance.toJSON() : <any>undefined;
        data["batchId"] = this.batchId;
        data["subscriptionId"] = this.subscriptionId;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Transaction();
        result.init(json);
        return result;
    }
}

export class Money {
    currency?: string | undefined;
    amount?: number | undefined;

    init(data?: any) {
        if (data) {
            this.currency = data["currency"];
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): Money {
        let result = new Money();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currency"] = this.currency;
        data["amount"] = this.amount;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Money();
        result.init(json);
        return result;
    }
}

export class ResultSetOfPaymentInfo {
    count?: number | undefined;
    items?: Payment[] | undefined;

    init(data?: any) {
        if (data) {
            this.count = data["count"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Payment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultSetOfPaymentInfo {
        let result = new ResultSetOfPaymentInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ResultSetOfPaymentInfo();
        result.init(json);
        return result;
    }
}

export class UpdateApprovalRequest {
    approval?: UpdateApprovalRequestApproval | undefined;

    init(data?: any) {
        if (data) {
            this.approval = data["approval"];
        }
    }

    static fromJS(data: any): UpdateApprovalRequest {
        let result = new UpdateApprovalRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approval"] = this.approval;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UpdateApprovalRequest();
        result.init(json);
        return result;
    }
}

export class DocumentStatusResponse {
    status?: DocumentStatusResponseStatus | undefined;

    init(data?: any) {
        if (data) {
            this.status = data["status"];
        }
    }

    static fromJS(data: any): DocumentStatusResponse {
        let result = new DocumentStatusResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new DocumentStatusResponse();
        result.init(json);
        return result;
    }
}

export class ChangeDocumentStatusRequest {
    status?: ChangeDocumentStatusRequestStatus | undefined;
    validationRules?: boolean | undefined;

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.validationRules = data["validationRules"];
        }
    }

    static fromJS(data: any): ChangeDocumentStatusRequest {
        let result = new ChangeDocumentStatusRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["validationRules"] = this.validationRules;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ChangeDocumentStatusRequest();
        result.init(json);
        return result;
    }
}

export class DocumentTrackingRequest {
    recipient: string;

    init(data?: any) {
        if (data) {
            this.recipient = data["recipient"];
        }
    }

    static fromJS(data: any): DocumentTrackingRequest {
        let result = new DocumentTrackingRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recipient"] = this.recipient;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new DocumentTrackingRequest();
        result.init(json);
        return result;
    }
}

export class Tracker {
    id?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
    printoutUrl?: string | undefined;

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.type = data["type"];
            this.url = data["url"];
            this.printoutUrl = data["printoutUrl"];
        }
    }

    static fromJS(data: any): Tracker {
        let result = new Tracker();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["url"] = this.url;
        data["printoutUrl"] = this.printoutUrl;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Tracker();
        result.init(json);
        return result;
    }
}

export class ResultSetOfTrackingInfo {
    count?: number | undefined;
    items?: Tracking[] | undefined;

    init(data?: any) {
        if (data) {
            this.count = data["count"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Tracking.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultSetOfTrackingInfo {
        let result = new ResultSetOfTrackingInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ResultSetOfTrackingInfo();
        result.init(json);
        return result;
    }
}

export class Tracking {
    reads?: number | undefined;
    recipient?: string | undefined;
    created?: Date | undefined;
    lastRead?: Date | undefined;
    tracker?: Tracker | undefined;

    init(data?: any) {
        if (data) {
            this.reads = data["reads"];
            this.recipient = data["recipient"];
            this.created = data["created"] ? new Date(data["created"].toString()) : <any>undefined;
            this.lastRead = data["lastRead"] ? new Date(data["lastRead"].toString()) : <any>undefined;
            this.tracker = data["tracker"] ? Tracker.fromJS(data["tracker"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Tracking {
        let result = new Tracking();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reads"] = this.reads;
        data["recipient"] = this.recipient;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastRead"] = this.lastRead ? this.lastRead.toISOString() : <any>undefined;
        data["tracker"] = this.tracker ? this.tracker.toJSON() : <any>undefined;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Tracking();
        result.init(json);
        return result;
    }
}

export class DocumentType {
    id?: string | undefined;
    code?: string | undefined;
    recordType?: DocumentTypeRecordType | undefined;
    name?: string | undefined;
    culture?: string | undefined;
    numberOffset?: number | undefined;
    numberFormat?: string | undefined;
    uiHint?: UiHint | undefined;
    template?: Attachment | undefined;
    notes?: string | undefined;
    tags?: string | undefined;
    generatesPrintouts?: boolean | undefined;
    paymentOptions?: PaymentOption[] | undefined;

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.code = data["code"];
            this.recordType = data["recordType"];
            this.name = data["name"];
            this.culture = data["culture"];
            this.numberOffset = data["numberOffset"];
            this.numberFormat = data["numberFormat"];
            this.uiHint = data["uiHint"] ? UiHint.fromJS(data["uiHint"]) : <any>undefined;
            this.template = data["template"] ? Attachment.fromJS(data["template"]) : <any>undefined;
            this.notes = data["notes"];
            this.tags = data["tags"];
            this.generatesPrintouts = data["generatesPrintouts"];
            if (data["paymentOptions"] && data["paymentOptions"].constructor === Array) {
                this.paymentOptions = [];
                for (let item of data["paymentOptions"])
                    this.paymentOptions.push(PaymentOption.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DocumentType {
        let result = new DocumentType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["recordType"] = this.recordType;
        data["name"] = this.name;
        data["culture"] = this.culture;
        data["numberOffset"] = this.numberOffset;
        data["numberFormat"] = this.numberFormat;
        data["uiHint"] = this.uiHint ? this.uiHint.toJSON() : <any>undefined;
        data["template"] = this.template ? this.template.toJSON() : <any>undefined;
        data["notes"] = this.notes;
        data["tags"] = this.tags;
        data["generatesPrintouts"] = this.generatesPrintouts;
        if (this.paymentOptions && this.paymentOptions.constructor === Array) {
            data["paymentOptions"] = [];
            for (let item of this.paymentOptions)
                data["paymentOptions"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new DocumentType();
        result.init(json);
        return result;
    }
}

export class Attachment {
    id?: string | undefined;
    guid?: string | undefined;
    name?: string | undefined;
    fileExtension?: string | undefined;
    contentType?: string | undefined;
    contentLength?: number | undefined;
    data?: string | undefined;
    readonly uri?: string | undefined;

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.guid = data["guid"];
            this.name = data["name"];
            this.fileExtension = data["fileExtension"];
            this.contentType = data["contentType"];
            this.contentLength = data["contentLength"];
            this.data = data["data"];
            (<any>this).uri = data["uri"];
        }
    }

    static fromJS(data: any): Attachment {
        let result = new Attachment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["guid"] = this.guid;
        data["name"] = this.name;
        data["fileExtension"] = this.fileExtension;
        data["contentType"] = this.contentType;
        data["contentLength"] = this.contentLength;
        data["data"] = this.data;
        data["uri"] = this.uri;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Attachment();
        result.init(json);
        return result;
    }
}

export class PaymentOption {
    id?: string | undefined;
    type: PaymentOptionType;
    code?: string | undefined;
    name: string;
    description: string;
    provider?: Service | undefined;

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.type = data["type"];
            this.code = data["code"];
            this.name = data["name"];
            this.description = data["description"];
            this.provider = data["provider"] ? Service.fromJS(data["provider"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PaymentOption {
        let result = new PaymentOption();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["provider"] = this.provider ? this.provider.toJSON() : <any>undefined;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PaymentOption();
        result.init(json);
        return result;
    }
}

export class ChangeDocumentTypeRequest {
    typeId?: string | undefined;

    init(data?: any) {
        if (data) {
            this.typeId = data["typeId"];
        }
    }

    static fromJS(data: any): ChangeDocumentTypeRequest {
        let result = new ChangeDocumentTypeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ChangeDocumentTypeRequest();
        result.init(json);
        return result;
    }
}

export class ResultSetOfDocumentTypeInfo {
    count?: number | undefined;
    items?: DocumentType[] | undefined;

    init(data?: any) {
        if (data) {
            this.count = data["count"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(DocumentType.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultSetOfDocumentTypeInfo {
        let result = new ResultSetOfDocumentTypeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ResultSetOfDocumentTypeInfo();
        result.init(json);
        return result;
    }
}

export class CreateDocumentTypeRequest {
    name: string;
    code?: string | undefined;
    culture?: string | undefined;
    numberOffset?: number | undefined;
    recordType?: CreateDocumentTypeRequestRecordType | undefined;
    numberFormat?: string | undefined;
    tags?: string | undefined;
    notes?: string | undefined;
    uiHint?: UiHint | undefined;
    generatesPrintouts?: boolean | undefined;

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.code = data["code"];
            this.culture = data["culture"];
            this.numberOffset = data["numberOffset"];
            this.recordType = data["recordType"];
            this.numberFormat = data["numberFormat"];
            this.tags = data["tags"];
            this.notes = data["notes"];
            this.uiHint = data["uiHint"] ? UiHint.fromJS(data["uiHint"]) : <any>undefined;
            this.generatesPrintouts = data["generatesPrintouts"];
        }
    }

    static fromJS(data: any): CreateDocumentTypeRequest {
        let result = new CreateDocumentTypeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["culture"] = this.culture;
        data["numberOffset"] = this.numberOffset;
        data["recordType"] = this.recordType;
        data["numberFormat"] = this.numberFormat;
        data["tags"] = this.tags;
        data["notes"] = this.notes;
        data["uiHint"] = this.uiHint ? this.uiHint.toJSON() : <any>undefined;
        data["generatesPrintouts"] = this.generatesPrintouts;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CreateDocumentTypeRequest();
        result.init(json);
        return result;
    }
}

export class UpdateDocumentTypeRequest {
    name: string;
    code?: string | undefined;
    culture?: string | undefined;
    numberOffset?: number | undefined;
    recordType?: UpdateDocumentTypeRequestRecordType | undefined;
    numberFormat?: string | undefined;
    tags?: string | undefined;
    notes?: string | undefined;
    uiHint?: UiHint | undefined;
    generatesPrintouts?: boolean | undefined;

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.code = data["code"];
            this.culture = data["culture"];
            this.numberOffset = data["numberOffset"];
            this.recordType = data["recordType"];
            this.numberFormat = data["numberFormat"];
            this.tags = data["tags"];
            this.notes = data["notes"];
            this.uiHint = data["uiHint"] ? UiHint.fromJS(data["uiHint"]) : <any>undefined;
            this.generatesPrintouts = data["generatesPrintouts"];
        }
    }

    static fromJS(data: any): UpdateDocumentTypeRequest {
        let result = new UpdateDocumentTypeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["culture"] = this.culture;
        data["numberOffset"] = this.numberOffset;
        data["recordType"] = this.recordType;
        data["numberFormat"] = this.numberFormat;
        data["tags"] = this.tags;
        data["notes"] = this.notes;
        data["uiHint"] = this.uiHint ? this.uiHint.toJSON() : <any>undefined;
        data["generatesPrintouts"] = this.generatesPrintouts;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UpdateDocumentTypeRequest();
        result.init(json);
        return result;
    }
}

export class ResultSetOfPaymentOptionInfo {
    count?: number | undefined;
    items?: PaymentOption[] | undefined;

    init(data?: any) {
        if (data) {
            this.count = data["count"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PaymentOption.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultSetOfPaymentOptionInfo {
        let result = new ResultSetOfPaymentOptionInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ResultSetOfPaymentOptionInfo();
        result.init(json);
        return result;
    }
}

export class ResultSetOfSubscriptionMemberInfo {
    count?: number | undefined;
    items?: SubscriptionMember[] | undefined;

    init(data?: any) {
        if (data) {
            this.count = data["count"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(SubscriptionMember.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultSetOfSubscriptionMemberInfo {
        let result = new ResultSetOfSubscriptionMemberInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ResultSetOfSubscriptionMemberInfo();
        result.init(json);
        return result;
    }
}

export class SubscriptionMember {
    memberId?: string | undefined;
    memberType?: SubscriptionMemberMemberType | undefined;

    init(data?: any) {
        if (data) {
            this.memberId = data["memberId"];
            this.memberType = data["memberType"];
        }
    }

    static fromJS(data: any): SubscriptionMember {
        let result = new SubscriptionMember();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["memberType"] = this.memberType;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new SubscriptionMember();
        result.init(json);
        return result;
    }
}

export class ResultSetOfMetricsRecord {
    summary?: Metrics | undefined;
    count?: number | undefined;
    items?: MetricsRecord[] | undefined;

    init(data?: any) {
        if (data) {
            this.summary = data["summary"] ? Metrics.fromJS(data["summary"]) : <any>undefined;
            this.count = data["count"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(MetricsRecord.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultSetOfMetricsRecord {
        let result = new ResultSetOfMetricsRecord();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["summary"] = this.summary ? this.summary.toJSON() : <any>undefined;
        data["count"] = this.count;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ResultSetOfMetricsRecord();
        result.init(json);
        return result;
    }
}

export class Metrics {
    requests?: number | undefined;
    requestsPerMinute?: number | undefined;
    writes?: number | undefined;
    reads?: number | undefined;
    documents?: number | undefined;

    init(data?: any) {
        if (data) {
            this.requests = data["requests"];
            this.requestsPerMinute = data["requestsPerMinute"];
            this.writes = data["writes"];
            this.reads = data["reads"];
            this.documents = data["documents"];
        }
    }

    static fromJS(data: any): Metrics {
        let result = new Metrics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requests"] = this.requests;
        data["requestsPerMinute"] = this.requestsPerMinute;
        data["writes"] = this.writes;
        data["reads"] = this.reads;
        data["documents"] = this.documents;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Metrics();
        result.init(json);
        return result;
    }
}

export class MetricsRecord {
    timestamp?: Date | undefined;
    period?: string | undefined;
    metrics?: Metrics | undefined;

    init(data?: any) {
        if (data) {
            this.timestamp = data["timestamp"] ? new Date(data["timestamp"].toString()) : <any>undefined;
            this.period = data["period"];
            this.metrics = data["metrics"] ? Metrics.fromJS(data["metrics"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MetricsRecord {
        let result = new MetricsRecord();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["period"] = this.period;
        data["metrics"] = this.metrics ? this.metrics.toJSON() : <any>undefined;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new MetricsRecord();
        result.init(json);
        return result;
    }
}

export class UpdateOrganisationRequest {
    code?: string | undefined;
    logoPath?: string | undefined;
    name: string;
    legalName?: string | undefined;
    lineOfBusiness?: string | undefined;
    taxCode?: string | undefined;
    taxOffice?: string | undefined;
    currencyCode?: string | undefined;
    address?: Address | undefined;
    email?: string | undefined;
    website?: string | undefined;
    notes?: string | undefined;
    customData?: any | undefined;
    paymentMethods?: PaymentMethod[] | undefined;

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.logoPath = data["logoPath"];
            this.name = data["name"];
            this.legalName = data["legalName"];
            this.lineOfBusiness = data["lineOfBusiness"];
            this.taxCode = data["taxCode"];
            this.taxOffice = data["taxOffice"];
            this.currencyCode = data["currencyCode"];
            this.address = data["address"] ? Address.fromJS(data["address"]) : <any>undefined;
            this.email = data["email"];
            this.website = data["website"];
            this.notes = data["notes"];
            if (data["customData"]) {
                this.customData = {};
                for (let key in data["customData"]) {
                    if (data["customData"].hasOwnProperty(key))
                        this.customData[key] = data["customData"][key];
                }
            }
            if (data["paymentMethods"] && data["paymentMethods"].constructor === Array) {
                this.paymentMethods = [];
                for (let item of data["paymentMethods"])
                    this.paymentMethods.push(PaymentMethod.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateOrganisationRequest {
        let result = new UpdateOrganisationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["logoPath"] = this.logoPath;
        data["name"] = this.name;
        data["legalName"] = this.legalName;
        data["lineOfBusiness"] = this.lineOfBusiness;
        data["taxCode"] = this.taxCode;
        data["taxOffice"] = this.taxOffice;
        data["currencyCode"] = this.currencyCode;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["email"] = this.email;
        data["website"] = this.website;
        data["notes"] = this.notes;
        if (this.customData) {
            data["customData"] = {};
            for (let key in this.customData) {
                if (this.customData.hasOwnProperty(key))
                    data["customData"][key] = this.customData[key];
            }
        }
        if (this.paymentMethods && this.paymentMethods.constructor === Array) {
            data["paymentMethods"] = [];
            for (let item of this.paymentMethods)
                data["paymentMethods"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UpdateOrganisationRequest();
        result.init(json);
        return result;
    }
}

export class ResultSetOfTransactionInfo {
    count?: number | undefined;
    items?: Transaction[] | undefined;

    init(data?: any) {
        if (data) {
            this.count = data["count"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Transaction.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultSetOfTransactionInfo {
        let result = new ResultSetOfTransactionInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ResultSetOfTransactionInfo();
        result.init(json);
        return result;
    }
}

export class BulkLoadTransactionsRequest {
    batchId?: string | undefined;
    data: Transaction[] = [];

    init(data?: any) {
        if (data) {
            this.batchId = data["batchId"];
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [];
                for (let item of data["data"])
                    this.data.push(Transaction.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BulkLoadTransactionsRequest {
        let result = new BulkLoadTransactionsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["batchId"] = this.batchId;
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new BulkLoadTransactionsRequest();
        result.init(json);
        return result;
    }
}

export class ResultSetOfProductInfo {
    count?: number | undefined;
    items?: Product[] | undefined;

    init(data?: any) {
        if (data) {
            this.count = data["count"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Product.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultSetOfProductInfo {
        let result = new ResultSetOfProductInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ResultSetOfProductInfo();
        result.init(json);
        return result;
    }
}

export class UpdateSubscriptionStatusRequest {
    status?: UpdateSubscriptionStatusRequestStatus | undefined;

    init(data?: any) {
        if (data) {
            this.status = data["status"];
        }
    }

    static fromJS(data: any): UpdateSubscriptionStatusRequest {
        let result = new UpdateSubscriptionStatusRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UpdateSubscriptionStatusRequest();
        result.init(json);
        return result;
    }
}

export class UpdateSubscriptionTimeZoneRequest {
    timeZone?: string | undefined;

    init(data?: any) {
        if (data) {
            this.timeZone = data["timeZone"];
        }
    }

    static fromJS(data: any): UpdateSubscriptionTimeZoneRequest {
        let result = new UpdateSubscriptionTimeZoneRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZone"] = this.timeZone;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UpdateSubscriptionTimeZoneRequest();
        result.init(json);
        return result;
    }
}

export class ResultSetOfTimeZone {
    count?: number | undefined;
    items?: TimeZone[] | undefined;

    init(data?: any) {
        if (data) {
            this.count = data["count"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TimeZone.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultSetOfTimeZone {
        let result = new ResultSetOfTimeZone();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ResultSetOfTimeZone();
        result.init(json);
        return result;
    }
}

export class TimeZone {
    readonly baseUtcOffset?: string | undefined;
    readonly id?: string | undefined;
    readonly standardName?: string | undefined;
    readonly daylightName?: string | undefined;
    readonly latitude?: number | undefined;
    readonly longitude?: number | undefined;
    readonly countryName?: string | undefined;
    displayName?: string | undefined;

    init(data?: any) {
        if (data) {
            (<any>this).baseUtcOffset = data["baseUtcOffset"];
            (<any>this).id = data["id"];
            (<any>this).standardName = data["standardName"];
            (<any>this).daylightName = data["daylightName"];
            (<any>this).latitude = data["latitude"];
            (<any>this).longitude = data["longitude"];
            (<any>this).countryName = data["countryName"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): TimeZone {
        let result = new TimeZone();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseUtcOffset"] = this.baseUtcOffset;
        data["id"] = this.id;
        data["standardName"] = this.standardName;
        data["daylightName"] = this.daylightName;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["countryName"] = this.countryName;
        data["displayName"] = this.displayName;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new TimeZone();
        result.init(json);
        return result;
    }
}

export enum Status {
    Draft = <any>"Draft", 
    Issued = <any>"Issued", 
    Overdue = <any>"Overdue", 
    Partial = <any>"Partial", 
    Paid = <any>"Paid", 
    Void = <any>"Void", 
    Deleted = <any>"Deleted", 
}

export enum RecordType {
    AccountsReceivable = <any>"AccountsReceivable", 
    AccountsPayable = <any>"AccountsPayable", 
}

export enum SubscriptionStatus {
    Enabled = <any>"Enabled", 
    Disabled = <any>"Disabled", 
    Deleted = <any>"Deleted", 
}

export enum PaymentMethodType {
    BankTransfer = <any>"BankTransfer", 
    Online = <any>"Online", 
    UponDelivery = <any>"UponDelivery", 
}

export enum AccentColorType {
    Bright = <any>"Bright", 
    Dark = <any>"Dark", 
}

export enum CreateSubscriptionRequestType {
    Sandbox = <any>"Sandbox", 
    Trial = <any>"Trial", 
    Basic = <any>"Basic", 
    Pro = <any>"Pro", 
    Custom = <any>"Custom", 
}

export enum DocumentStatus {
    Draft = <any>"Draft", 
    Issued = <any>"Issued", 
    Overdue = <any>"Overdue", 
    Partial = <any>"Partial", 
    Paid = <any>"Paid", 
    Void = <any>"Void", 
    Deleted = <any>"Deleted", 
}

export enum TaxType {
    UnitRate = <any>"UnitRate", 
    FixedRate = <any>"FixedRate", 
    Fixed = <any>"Fixed", 
}

export enum CreateDocumentRequestStatus {
    Draft = <any>"Draft", 
    Issued = <any>"Issued", 
    Overdue = <any>"Overdue", 
    Partial = <any>"Partial", 
    Paid = <any>"Paid", 
    Void = <any>"Void", 
    Deleted = <any>"Deleted", 
}

export enum PaymentApproval {
    Pending = <any>"Pending", 
    Approved = <any>"Approved", 
    Rejected = <any>"Rejected", 
}

export enum TransactionType {
    Credit = <any>"Credit", 
    Debit = <any>"Debit", 
}

export enum UpdateApprovalRequestApproval {
    Pending = <any>"Pending", 
    Approved = <any>"Approved", 
    Rejected = <any>"Rejected", 
}

export enum DocumentStatusResponseStatus {
    Draft = <any>"Draft", 
    Issued = <any>"Issued", 
    Overdue = <any>"Overdue", 
    Partial = <any>"Partial", 
    Paid = <any>"Paid", 
    Void = <any>"Void", 
    Deleted = <any>"Deleted", 
}

export enum ChangeDocumentStatusRequestStatus {
    Draft = <any>"Draft", 
    Issued = <any>"Issued", 
    Overdue = <any>"Overdue", 
    Partial = <any>"Partial", 
    Paid = <any>"Paid", 
    Void = <any>"Void", 
    Deleted = <any>"Deleted", 
}

export enum DocumentTypeRecordType {
    AccountsReceivable = <any>"AccountsReceivable", 
    AccountsPayable = <any>"AccountsPayable", 
}

export enum PaymentOptionType {
    Info = <any>"Info", 
    AISP = <any>"AISP", 
    PISP = <any>"PISP", 
}

export enum CreateDocumentTypeRequestRecordType {
    AccountsReceivable = <any>"AccountsReceivable", 
    AccountsPayable = <any>"AccountsPayable", 
}

export enum UpdateDocumentTypeRequestRecordType {
    AccountsReceivable = <any>"AccountsReceivable", 
    AccountsPayable = <any>"AccountsPayable", 
}

export enum SubscriptionMemberMemberType {
    Application = <any>"Application", 
    User = <any>"User", 
}

export enum UpdateSubscriptionStatusRequestStatus {
    Enabled = <any>"Enabled", 
    Disabled = <any>"Disabled", 
    Deleted = <any>"Deleted", 
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}
